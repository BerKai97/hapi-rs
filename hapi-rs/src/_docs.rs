/* automatically generated by rust-bindgen 0.55.1 */

// hapi-sys version 0.1.1

pub const HAPI_POSITION_VECTOR_SIZE: u32 = 3;
pub const HAPI_SCALE_VECTOR_SIZE: u32 = 3;
pub const HAPI_SHEAR_VECTOR_SIZE: u32 = 3;
pub const HAPI_NORMAL_VECTOR_SIZE: u32 = 3;
pub const HAPI_QUATERNION_VECTOR_SIZE: u32 = 4;
pub const HAPI_EULER_VECTOR_SIZE: u32 = 3;
pub const HAPI_UV_VECTOR_SIZE: u32 = 2;
pub const HAPI_COLOR_VECTOR_SIZE: u32 = 4;
pub const HAPI_CV_VECTOR_SIZE: u32 = 4;
pub const HAPI_PRIM_MIN_VERTEX_COUNT: u32 = 1;
pub const HAPI_PRIM_MAX_VERTEX_COUNT: u32 = 16;
pub const HAPI_INVALID_PARM_ID: i32 = -1;
pub const HAPI_ATTRIB_POSITION: &'static [u8; 2usize] = b"P\0";
pub const HAPI_ATTRIB_UV: &'static [u8; 3usize] = b"uv\0";
pub const HAPI_ATTRIB_UV2: &'static [u8; 4usize] = b"uv2\0";
pub const HAPI_ATTRIB_NORMAL: &'static [u8; 2usize] = b"N\0";
pub const HAPI_ATTRIB_TANGENT: &'static [u8; 9usize] = b"tangentu\0";
pub const HAPI_ATTRIB_TANGENT2: &'static [u8; 9usize] = b"tangentv\0";
pub const HAPI_ATTRIB_COLOR: &'static [u8; 3usize] = b"Cd\0";
pub const HAPI_ATTRIB_NAME: &'static [u8; 5usize] = b"name\0";
pub const HAPI_ATTRIB_INSTANCE: &'static [u8; 9usize] = b"instance\0";
pub const HAPI_UNGROUPED_GROUP_NAME: &'static [u8; 18usize] = b"__ungrouped_group\0";
pub const HAPI_RAW_FORMAT_NAME: &'static [u8; 9usize] = b"HAPI_RAW\0";
pub const HAPI_PNG_FORMAT_NAME: &'static [u8; 4usize] = b"PNG\0";
pub const HAPI_JPEG_FORMAT_NAME: &'static [u8; 5usize] = b"JPEG\0";
pub const HAPI_BMP_FORMAT_NAME: &'static [u8; 7usize] = b"Bitmap\0";
pub const HAPI_TIFF_FORMAT_NAME: &'static [u8; 5usize] = b"TIFF\0";
pub const HAPI_TGA_FORMAT_NAME: &'static [u8; 6usize] = b"Targa\0";
pub const HAPI_DEFAULT_IMAGE_FORMAT_NAME: &'static [u8; 4usize] = b"PNG\0";
pub const HAPI_GLOBAL_NODES_NODE_NAME: &'static [u8; 12usize] = b"GlobalNodes\0";
pub const HAPI_ENV_HIP: &'static [u8; 4usize] = b"HIP\0";
pub const HAPI_ENV_JOB: &'static [u8; 4usize] = b"JOB\0";
pub const HAPI_ENV_CLIENT_NAME: &'static [u8; 17usize] = b"HAPI_CLIENT_NAME\0";
pub const HAPI_CACHE_COP_COOK: &'static [u8; 15usize] = b"COP Cook Cache\0";
pub const HAPI_CACHE_COP_FLIPBOOK: &'static [u8; 19usize] = b"COP Flipbook Cache\0";
pub const HAPI_CACHE_IMAGE: &'static [u8; 12usize] = b"Image Cache\0";
pub const HAPI_CACHE_OBJ: &'static [u8; 23usize] = b"Object Transform Cache\0";
pub const HAPI_CACHE_GL_TEXTURE: &'static [u8; 21usize] = b"OpenGL Texture Cache\0";
pub const HAPI_CACHE_GL_VERTEX: &'static [u8; 20usize] = b"OpenGL Vertex Cache\0";
pub const HAPI_CACHE_SOP: &'static [u8; 10usize] = b"SOP Cache\0";
pub const HAPI_CACHE_VEX: &'static [u8; 15usize] = b"VEX File Cache\0";
pub const HAPI_VERSION_HOUDINI_MAJOR: u32 = 18;
pub const HAPI_VERSION_HOUDINI_MINOR: u32 = 5;
pub const HAPI_VERSION_HOUDINI_BUILD: u32 = 351;
pub const HAPI_VERSION_HOUDINI_PATCH: u32 = 0;
pub const HAPI_VERSION_HOUDINI_ENGINE_MAJOR: u32 = 3;
pub const HAPI_VERSION_HOUDINI_ENGINE_MINOR: u32 = 5;
pub const HAPI_VERSION_HOUDINI_ENGINE_API: u32 = 0;
pub type HAPI_Bool = ::std::os::raw::c_char;
pub type HAPI_Int64 = ::std::os::raw::c_longlong;
pub type static_assert_unsupported_size_of_long = [::std::os::raw::c_char; 1usize];
pub type HAPI_ProcessId = ::std::os::raw::c_int;
#[doc = " Has to be 64-bit."]
pub type HAPI_SessionId = HAPI_Int64;
#[doc = " Use this with HAPI_GetString() to get the value."]
#[doc = " See @ref HAPI_Fundamentals_Strings."]
pub type HAPI_StringHandle = ::std::os::raw::c_int;
pub type HAPI_AssetLibraryId = ::std::os::raw::c_int;
#[doc = " See @ref HAPI_Nodes_Basics."]
pub type HAPI_NodeId = ::std::os::raw::c_int;
#[doc = " Either get this from the ::HAPI_ParmInfo or ::HAPI_GetParmIdFromName()."]
#[doc = " See @ref HAPI_Parameters."]
pub type HAPI_ParmId = ::std::os::raw::c_int;
#[doc = " Use this with ::HAPI_GetPartInfo()."]
#[doc = " See @ref HAPI_Parts."]
pub type HAPI_PartId = ::std::os::raw::c_int;
#[doc = " Use this with PDG functions"]
pub type HAPI_PDG_WorkitemId = ::std::os::raw::c_int;
#[doc = " Use this with PDG functions"]
pub type HAPI_PDG_GraphContextId = ::std::os::raw::c_int;
#[doc = " When we load a HIP file, we associate a HIP file ID with the created nodes"]
#[doc = " so that they can be looked up later"]
pub type HAPI_HIPFileId = ::std::os::raw::c_int;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_License {
    HAPI_LICENSE_NONE = 0,
    HAPI_LICENSE_HOUDINI_ENGINE = 1,
    HAPI_LICENSE_HOUDINI = 2,
    HAPI_LICENSE_HOUDINI_FX = 3,
    HAPI_LICENSE_HOUDINI_ENGINE_INDIE = 4,
    HAPI_LICENSE_HOUDINI_INDIE = 5,
    HAPI_LICENSE_MAX = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_StatusType {
    HAPI_STATUS_CALL_RESULT = 0,
    HAPI_STATUS_COOK_RESULT = 1,
    HAPI_STATUS_COOK_STATE = 2,
    HAPI_STATUS_MAX = 3,
}
impl HAPI_StatusVerbosity {
    pub const HAPI_STATUSVERBOSITY_ALL: HAPI_StatusVerbosity =
        HAPI_StatusVerbosity::HAPI_STATUSVERBOSITY_2;
}
impl HAPI_StatusVerbosity {
    pub const HAPI_STATUSVERBOSITY_ERRORS: HAPI_StatusVerbosity =
        HAPI_StatusVerbosity::HAPI_STATUSVERBOSITY_0;
}
impl HAPI_StatusVerbosity {
    pub const HAPI_STATUSVERBOSITY_WARNINGS: HAPI_StatusVerbosity =
        HAPI_StatusVerbosity::HAPI_STATUSVERBOSITY_1;
}
impl HAPI_StatusVerbosity {
    pub const HAPI_STATUSVERBOSITY_MESSAGES: HAPI_StatusVerbosity =
        HAPI_StatusVerbosity::HAPI_STATUSVERBOSITY_2;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_StatusVerbosity {
    HAPI_STATUSVERBOSITY_0 = 0,
    HAPI_STATUSVERBOSITY_1 = 1,
    HAPI_STATUSVERBOSITY_2 = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_Result {
    HAPI_RESULT_SUCCESS = 0,
    HAPI_RESULT_FAILURE = 1,
    HAPI_RESULT_ALREADY_INITIALIZED = 2,
    HAPI_RESULT_NOT_INITIALIZED = 3,
    HAPI_RESULT_CANT_LOADFILE = 4,
    HAPI_RESULT_PARM_SET_FAILED = 5,
    HAPI_RESULT_INVALID_ARGUMENT = 6,
    HAPI_RESULT_CANT_LOAD_GEO = 7,
    HAPI_RESULT_CANT_GENERATE_PRESET = 8,
    HAPI_RESULT_CANT_LOAD_PRESET = 9,
    HAPI_RESULT_ASSET_DEF_ALREADY_LOADED = 10,
    HAPI_RESULT_NO_LICENSE_FOUND = 110,
    HAPI_RESULT_DISALLOWED_NC_LICENSE_FOUND = 120,
    HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_C_LICENSE = 130,
    HAPI_RESULT_DISALLOWED_NC_ASSET_WITH_LC_LICENSE = 140,
    HAPI_RESULT_DISALLOWED_LC_ASSET_WITH_C_LICENSE = 150,
    HAPI_RESULT_DISALLOWED_HENGINEINDIE_W_3PARTY_PLUGIN = 160,
    HAPI_RESULT_ASSET_INVALID = 200,
    HAPI_RESULT_NODE_INVALID = 210,
    HAPI_RESULT_USER_INTERRUPTED = 300,
    HAPI_RESULT_INVALID_SESSION = 400,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_ErrorCode {
    HAPI_ERRORCODE_ASSET_DEF_NOT_FOUND = 1,
    HAPI_ERRORCODE_PYTHON_NODE_ERROR = 2,
}
pub type HAPI_ErrorCodeBits = ::std::os::raw::c_int;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_SessionType {
    HAPI_SESSION_INPROCESS = 0,
    HAPI_SESSION_THRIFT = 1,
    HAPI_SESSION_CUSTOM1 = 2,
    HAPI_SESSION_CUSTOM2 = 3,
    HAPI_SESSION_CUSTOM3 = 4,
    HAPI_SESSION_MAX = 5,
}
impl HAPI_State {
    pub const HAPI_STATE_MAX_READY_STATE: HAPI_State =
        HAPI_State::HAPI_STATE_READY_WITH_COOK_ERRORS;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_State {
    #[doc = "< Everything cook successfully without errors."]
    HAPI_STATE_READY = 0,
    #[doc = "< You should abort the cook."]
    HAPI_STATE_READY_WITH_FATAL_ERRORS = 1,
    #[doc = "< Only some objects failed."]
    HAPI_STATE_READY_WITH_COOK_ERRORS = 2,
    HAPI_STATE_STARTING_COOK = 3,
    HAPI_STATE_COOKING = 4,
    HAPI_STATE_STARTING_LOAD = 5,
    HAPI_STATE_LOADING = 6,
    HAPI_STATE_MAX = 7,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PackedPrimInstancingMode {
    HAPI_PACKEDPRIM_INSTANCING_MODE_INVALID = -1,
    HAPI_PACKEDPRIM_INSTANCING_MODE_DISABLED = 0,
    HAPI_PACKEDPRIM_INSTANCING_MODE_HIERARCHY = 1,
    HAPI_PACKEDPRIM_INSTANCING_MODE_FLAT = 2,
    HAPI_PACKEDPRIM_INSTANCING_MODE_MAX = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_Permissions {
    HAPI_PERMISSIONS_NON_APPLICABLE = 0,
    HAPI_PERMISSIONS_READ_WRITE = 1,
    HAPI_PERMISSIONS_READ_ONLY = 2,
    HAPI_PERMISSIONS_WRITE_ONLY = 3,
    HAPI_PERMISSIONS_MAX = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_RampType {
    HAPI_RAMPTYPE_INVALID = -1,
    HAPI_RAMPTYPE_FLOAT = 0,
    HAPI_RAMPTYPE_COLOR = 1,
    HAPI_RAMPTYPE_MAX = 2,
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_INT_START: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_INT;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_INT_END: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_BUTTON;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_FLOAT_START: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_FLOAT;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_FLOAT_END: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_COLOR;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_STRING_START: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_STRING;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_STRING_END: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_NODE;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_PATH_START: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_PATH_FILE;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_PATH_END: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_PATH_FILE_IMAGE;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_NODE_START: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_NODE;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_NODE_END: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_NODE;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_CONTAINER_START: HAPI_ParmType =
        HAPI_ParmType::HAPI_PARMTYPE_FOLDERLIST;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_CONTAINER_END: HAPI_ParmType =
        HAPI_ParmType::HAPI_PARMTYPE_FOLDERLIST_RADIO;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_NONVALUE_START: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_FOLDER;
}
impl HAPI_ParmType {
    pub const HAPI_PARMTYPE_NONVALUE_END: HAPI_ParmType = HAPI_ParmType::HAPI_PARMTYPE_SEPARATOR;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " As you can see, some of these high level types share the same underlying"]
#[doc = " raw data type. For instance, both string and file parameter types can be"]
#[doc = " represented with strings, yet semantically they are different. We will"]
#[doc = " group high level parameter types that share an underlying raw data type"]
#[doc = " together, so you can always check the raw data type of a parameter based"]
#[doc = " on its high level data type by checking a range of values."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_ParmType {
    HAPI_PARMTYPE_INT = 0,
    HAPI_PARMTYPE_MULTIPARMLIST = 1,
    HAPI_PARMTYPE_TOGGLE = 2,
    HAPI_PARMTYPE_BUTTON = 3,
    HAPI_PARMTYPE_FLOAT = 4,
    HAPI_PARMTYPE_COLOR = 5,
    HAPI_PARMTYPE_STRING = 6,
    HAPI_PARMTYPE_PATH_FILE = 7,
    HAPI_PARMTYPE_PATH_FILE_GEO = 8,
    HAPI_PARMTYPE_PATH_FILE_IMAGE = 9,
    HAPI_PARMTYPE_NODE = 10,
    HAPI_PARMTYPE_FOLDERLIST = 11,
    HAPI_PARMTYPE_FOLDERLIST_RADIO = 12,
    HAPI_PARMTYPE_FOLDER = 13,
    HAPI_PARMTYPE_LABEL = 14,
    HAPI_PARMTYPE_SEPARATOR = 15,
    HAPI_PARMTYPE_PATH_FILE_DIR = 16,
    #[doc = "< Total number of supported parameter types."]
    HAPI_PARMTYPE_MAX = 17,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Corresponds to the types as shown in the Houdini Type Properties"]
#[doc = " window and in DialogScript files.  Available on HAPI_ParmInfo"]
#[doc = " See: <a href=\"http://www.sidefx.com/docs/houdini/ref/windows/optype.html#parmtypes\">Parameter types</a>"]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PrmScriptType {
    #[doc = "<  \"int\", \"integer\""]
    HAPI_PRM_SCRIPT_TYPE_INT = 0,
    HAPI_PRM_SCRIPT_TYPE_FLOAT = 1,
    HAPI_PRM_SCRIPT_TYPE_ANGLE = 2,
    HAPI_PRM_SCRIPT_TYPE_STRING = 3,
    HAPI_PRM_SCRIPT_TYPE_FILE = 4,
    HAPI_PRM_SCRIPT_TYPE_DIRECTORY = 5,
    HAPI_PRM_SCRIPT_TYPE_IMAGE = 6,
    HAPI_PRM_SCRIPT_TYPE_GEOMETRY = 7,
    #[doc = "<  \"toggle\", \"embed\""]
    HAPI_PRM_SCRIPT_TYPE_TOGGLE = 8,
    HAPI_PRM_SCRIPT_TYPE_BUTTON = 9,
    HAPI_PRM_SCRIPT_TYPE_VECTOR2 = 10,
    #[doc = "<  \"vector\", \"vector3\""]
    HAPI_PRM_SCRIPT_TYPE_VECTOR3 = 11,
    HAPI_PRM_SCRIPT_TYPE_VECTOR4 = 12,
    HAPI_PRM_SCRIPT_TYPE_INTVECTOR2 = 13,
    #[doc = "<  \"intvector\", \"intvector3\""]
    HAPI_PRM_SCRIPT_TYPE_INTVECTOR3 = 14,
    HAPI_PRM_SCRIPT_TYPE_INTVECTOR4 = 15,
    HAPI_PRM_SCRIPT_TYPE_UV = 16,
    HAPI_PRM_SCRIPT_TYPE_UVW = 17,
    #[doc = "<  \"dir\", \"direction\""]
    HAPI_PRM_SCRIPT_TYPE_DIR = 18,
    #[doc = "<  \"color\", \"rgb\""]
    HAPI_PRM_SCRIPT_TYPE_COLOR = 19,
    #[doc = "<  \"color4\", \"rgba\""]
    HAPI_PRM_SCRIPT_TYPE_COLOR4 = 20,
    HAPI_PRM_SCRIPT_TYPE_OPPATH = 21,
    HAPI_PRM_SCRIPT_TYPE_OPLIST = 22,
    HAPI_PRM_SCRIPT_TYPE_OBJECT = 23,
    HAPI_PRM_SCRIPT_TYPE_OBJECTLIST = 24,
    HAPI_PRM_SCRIPT_TYPE_RENDER = 25,
    HAPI_PRM_SCRIPT_TYPE_SEPARATOR = 26,
    HAPI_PRM_SCRIPT_TYPE_GEOMETRY_DATA = 27,
    HAPI_PRM_SCRIPT_TYPE_KEY_VALUE_DICT = 28,
    HAPI_PRM_SCRIPT_TYPE_LABEL = 29,
    HAPI_PRM_SCRIPT_TYPE_RGBAMASK = 30,
    HAPI_PRM_SCRIPT_TYPE_ORDINAL = 31,
    HAPI_PRM_SCRIPT_TYPE_RAMP_FLT = 32,
    HAPI_PRM_SCRIPT_TYPE_RAMP_RGB = 33,
    HAPI_PRM_SCRIPT_TYPE_FLOAT_LOG = 34,
    HAPI_PRM_SCRIPT_TYPE_INT_LOG = 35,
    HAPI_PRM_SCRIPT_TYPE_DATA = 36,
    HAPI_PRM_SCRIPT_TYPE_FLOAT_MINMAX = 37,
    HAPI_PRM_SCRIPT_TYPE_INT_MINMAX = 38,
    HAPI_PRM_SCRIPT_TYPE_INT_STARTEND = 39,
    HAPI_PRM_SCRIPT_TYPE_BUTTONSTRIP = 40,
    HAPI_PRM_SCRIPT_TYPE_ICONSTRIP = 41,
    #[doc = "< Radio buttons Folder"]
    HAPI_PRM_SCRIPT_TYPE_GROUPRADIO = 1000,
    #[doc = "< Collapsible Folder"]
    HAPI_PRM_SCRIPT_TYPE_GROUPCOLLAPSIBLE = 1001,
    #[doc = "< Simple Folder"]
    HAPI_PRM_SCRIPT_TYPE_GROUPSIMPLE = 1002,
    #[doc = "< Tabs Folder"]
    HAPI_PRM_SCRIPT_TYPE_GROUP = 1003,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_ChoiceListType {
    #[doc = "< Parameter is not a menu."]
    HAPI_CHOICELISTTYPE_NONE = 0,
    #[doc = "< Menu Only, Single Selection"]
    HAPI_CHOICELISTTYPE_NORMAL = 1,
    #[doc = "< Mini Menu Only, Single Selection"]
    HAPI_CHOICELISTTYPE_MINI = 2,
    #[doc = "< Field + Single Selection Menu"]
    HAPI_CHOICELISTTYPE_REPLACE = 3,
    #[doc = "< Field + Multiple Selection Menu"]
    HAPI_CHOICELISTTYPE_TOGGLE = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PresetType {
    HAPI_PRESETTYPE_INVALID = -1,
    #[doc = "< Just the presets binary blob."]
    HAPI_PRESETTYPE_BINARY = 0,
    #[doc = "< Presets blob within an .idx file format."]
    HAPI_PRESETTYPE_IDX = 1,
    HAPI_PRESETTYPE_MAX = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_NodeType {
    HAPI_NODETYPE_ANY = -1,
    HAPI_NODETYPE_NONE = 0,
    HAPI_NODETYPE_OBJ = 1,
    HAPI_NODETYPE_SOP = 2,
    HAPI_NODETYPE_CHOP = 4,
    HAPI_NODETYPE_ROP = 8,
    HAPI_NODETYPE_SHOP = 16,
    HAPI_NODETYPE_COP = 32,
    HAPI_NODETYPE_VOP = 64,
    HAPI_NODETYPE_DOP = 128,
    HAPI_NODETYPE_TOP = 256,
}
pub type HAPI_NodeTypeBits = ::std::os::raw::c_int;
#[repr(i32)]
#[non_exhaustive]
#[doc = " Flags used to filter compositions of node lists. Flags marked"]
#[doc = " 'Recursive Flag' will exclude children whos parent does not"]
#[doc = " satisfy the flag, even if the children themselves satisfy the flag."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_NodeFlags {
    HAPI_NODEFLAGS_ANY = -1,
    HAPI_NODEFLAGS_NONE = 0,
    #[doc = "< Recursive Flag"]
    HAPI_NODEFLAGS_DISPLAY = 1,
    #[doc = "< Recursive Flag"]
    HAPI_NODEFLAGS_RENDER = 2,
    HAPI_NODEFLAGS_TEMPLATED = 4,
    HAPI_NODEFLAGS_LOCKED = 8,
    HAPI_NODEFLAGS_EDITABLE = 16,
    HAPI_NODEFLAGS_BYPASS = 32,
    HAPI_NODEFLAGS_NETWORK = 64,
    #[doc = " OBJ Node Specific Flags"]
    HAPI_NODEFLAGS_OBJ_GEOMETRY = 128,
    #[doc = " OBJ Node Specific Flags"]
    HAPI_NODEFLAGS_OBJ_CAMERA = 256,
    #[doc = " OBJ Node Specific Flags"]
    HAPI_NODEFLAGS_OBJ_LIGHT = 512,
    #[doc = " OBJ Node Specific Flags"]
    HAPI_NODEFLAGS_OBJ_SUBNET = 1024,
    #[doc = "< Looks for \"curve\"."]
    HAPI_NODEFLAGS_SOP_CURVE = 2048,
    #[doc = "< Looks for Guide Geometry"]
    HAPI_NODEFLAGS_SOP_GUIDE = 4096,
    #[doc = " TOP Node Specific Flags"]
    HAPI_NODEFLAGS_TOP_NONSCHEDULER = 8192,
}
pub type HAPI_NodeFlagsBits = ::std::os::raw::c_int;
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_GroupType {
    HAPI_GROUPTYPE_INVALID = -1,
    HAPI_GROUPTYPE_POINT = 0,
    HAPI_GROUPTYPE_PRIM = 1,
    HAPI_GROUPTYPE_MAX = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_AttributeOwner {
    HAPI_ATTROWNER_INVALID = -1,
    HAPI_ATTROWNER_VERTEX = 0,
    HAPI_ATTROWNER_POINT = 1,
    HAPI_ATTROWNER_PRIM = 2,
    HAPI_ATTROWNER_DETAIL = 3,
    HAPI_ATTROWNER_MAX = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_CurveType {
    HAPI_CURVETYPE_INVALID = -1,
    HAPI_CURVETYPE_LINEAR = 0,
    HAPI_CURVETYPE_NURBS = 1,
    HAPI_CURVETYPE_BEZIER = 2,
    HAPI_CURVETYPE_MAX = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_VolumeType {
    HAPI_VOLUMETYPE_INVALID = -1,
    HAPI_VOLUMETYPE_HOUDINI = 0,
    HAPI_VOLUMETYPE_VDB = 1,
    HAPI_VOLUMETYPE_MAX = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_VolumeVisualType {
    HAPI_VOLUMEVISTYPE_INVALID = -1,
    HAPI_VOLUMEVISTYPE_SMOKE = 0,
    HAPI_VOLUMEVISTYPE_RAINBOW = 1,
    HAPI_VOLUMEVISTYPE_ISO = 2,
    HAPI_VOLUMEVISTYPE_INVISIBLE = 3,
    HAPI_VOLUMEVISTYPE_HEIGHTFIELD = 4,
    HAPI_VOLUMEVISTYPE_MAX = 5,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_StorageType {
    HAPI_STORAGETYPE_INVALID = -1,
    HAPI_STORAGETYPE_INT = 0,
    HAPI_STORAGETYPE_INT64 = 1,
    HAPI_STORAGETYPE_FLOAT = 2,
    HAPI_STORAGETYPE_FLOAT64 = 3,
    HAPI_STORAGETYPE_STRING = 4,
    HAPI_STORAGETYPE_MAX = 5,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_AttributeTypeInfo {
    HAPI_ATTRIBUTE_TYPE_INVALID = -1,
    HAPI_ATTRIBUTE_TYPE_NONE = 0,
    HAPI_ATTRIBUTE_TYPE_POINT = 1,
    HAPI_ATTRIBUTE_TYPE_HPOINT = 2,
    HAPI_ATTRIBUTE_TYPE_VECTOR = 3,
    HAPI_ATTRIBUTE_TYPE_NORMAL = 4,
    HAPI_ATTRIBUTE_TYPE_COLOR = 5,
    HAPI_ATTRIBUTE_TYPE_QUATERNION = 6,
    HAPI_ATTRIBUTE_TYPE_MATRIX3 = 7,
    HAPI_ATTRIBUTE_TYPE_MATRIX = 8,
    HAPI_ATTRIBUTE_TYPE_ST = 9,
    HAPI_ATTRIBUTE_TYPE_HIDDEN = 10,
    HAPI_ATTRIBUTE_TYPE_BOX2 = 11,
    HAPI_ATTRIBUTE_TYPE_BOX = 12,
    HAPI_ATTRIBUTE_TYPE_TEXTURE = 13,
    HAPI_ATTRIBUTE_TYPE_MAX = 14,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_GeoType {
    HAPI_GEOTYPE_INVALID = -1,
    #[doc = " Most geos will be of this type which essentially means a geo"]
    #[doc = " not of the other types."]
    HAPI_GEOTYPE_DEFAULT = 0,
    #[doc = " An exposed edit node."]
    #[doc = " See @ref HAPI_IntermediateAssetsResults."]
    HAPI_GEOTYPE_INTERMEDIATE = 1,
    #[doc = " An input geo that can accept geometry from the host."]
    #[doc = " See @ref HAPI_AssetInputs_MarshallingGeometryIntoHoudini."]
    HAPI_GEOTYPE_INPUT = 2,
    #[doc = " A curve."]
    #[doc = " See @ref HAPI_Curves."]
    HAPI_GEOTYPE_CURVE = 3,
    #[doc = " A curve."]
    #[doc = " See @ref HAPI_Curves."]
    HAPI_GEOTYPE_MAX = 4,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PartType {
    HAPI_PARTTYPE_INVALID = -1,
    HAPI_PARTTYPE_MESH = 0,
    HAPI_PARTTYPE_CURVE = 1,
    HAPI_PARTTYPE_VOLUME = 2,
    HAPI_PARTTYPE_INSTANCER = 3,
    HAPI_PARTTYPE_BOX = 4,
    HAPI_PARTTYPE_SPHERE = 5,
    HAPI_PARTTYPE_MAX = 6,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_InputType {
    HAPI_INPUT_INVALID = -1,
    HAPI_INPUT_TRANSFORM = 0,
    HAPI_INPUT_GEOMETRY = 1,
    HAPI_INPUT_MAX = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_CurveOrders {
    HAPI_CURVE_ORDER_VARYING = 0,
    HAPI_CURVE_ORDER_INVALID = 1,
    HAPI_CURVE_ORDER_LINEAR = 2,
    HAPI_CURVE_ORDER_QUADRATIC = 3,
    HAPI_CURVE_ORDER_CUBIC = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_TransformComponent {
    HAPI_TRANSFORM_TX = 0,
    HAPI_TRANSFORM_TY = 1,
    HAPI_TRANSFORM_TZ = 2,
    HAPI_TRANSFORM_RX = 3,
    HAPI_TRANSFORM_RY = 4,
    HAPI_TRANSFORM_RZ = 5,
    HAPI_TRANSFORM_QX = 6,
    HAPI_TRANSFORM_QY = 7,
    HAPI_TRANSFORM_QZ = 8,
    HAPI_TRANSFORM_QW = 9,
    HAPI_TRANSFORM_SX = 10,
    HAPI_TRANSFORM_SY = 11,
    HAPI_TRANSFORM_SZ = 12,
}
impl HAPI_RSTOrder {
    pub const HAPI_RSTORDER_DEFAULT: HAPI_RSTOrder = HAPI_RSTOrder::HAPI_SRT;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_RSTOrder {
    HAPI_TRS = 0,
    HAPI_TSR = 1,
    HAPI_RTS = 2,
    HAPI_RST = 3,
    HAPI_STR = 4,
    HAPI_SRT = 5,
}
impl HAPI_XYZOrder {
    pub const HAPI_XYZORDER_DEFAULT: HAPI_XYZOrder = HAPI_XYZOrder::HAPI_XYZ;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_XYZOrder {
    HAPI_XYZ = 0,
    HAPI_XZY = 1,
    HAPI_YXZ = 2,
    HAPI_YZX = 3,
    HAPI_ZXY = 4,
    HAPI_ZYX = 5,
}
impl HAPI_ImageDataFormat {
    pub const HAPI_IMAGE_DATA_DEFAULT: HAPI_ImageDataFormat =
        HAPI_ImageDataFormat::HAPI_IMAGE_DATA_INT8;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_ImageDataFormat {
    HAPI_IMAGE_DATA_UNKNOWN = -1,
    HAPI_IMAGE_DATA_INT8 = 0,
    HAPI_IMAGE_DATA_INT16 = 1,
    HAPI_IMAGE_DATA_INT32 = 2,
    HAPI_IMAGE_DATA_FLOAT16 = 3,
    HAPI_IMAGE_DATA_FLOAT32 = 4,
    HAPI_IMAGE_DATA_MAX = 5,
}
impl HAPI_ImagePacking {
    pub const HAPI_IMAGE_PACKING_DEFAULT3: HAPI_ImagePacking =
        HAPI_ImagePacking::HAPI_IMAGE_PACKING_RGB;
}
impl HAPI_ImagePacking {
    pub const HAPI_IMAGE_PACKING_DEFAULT4: HAPI_ImagePacking =
        HAPI_ImagePacking::HAPI_IMAGE_PACKING_RGBA;
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_ImagePacking {
    HAPI_IMAGE_PACKING_UNKNOWN = -1,
    #[doc = "< Single Channel"]
    HAPI_IMAGE_PACKING_SINGLE = 0,
    #[doc = "< Dual Channel"]
    HAPI_IMAGE_PACKING_DUAL = 1,
    #[doc = "< RGB"]
    HAPI_IMAGE_PACKING_RGB = 2,
    #[doc = "< RGB Reversed"]
    HAPI_IMAGE_PACKING_BGR = 3,
    #[doc = "< RGBA"]
    HAPI_IMAGE_PACKING_RGBA = 4,
    #[doc = "< RGBA Reversed"]
    HAPI_IMAGE_PACKING_ABGR = 5,
    HAPI_IMAGE_PACKING_MAX = 6,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " This enum is to be used with ::HAPI_GetEnvInt() to retrieve basic"]
#[doc = " information about the HAPI implementation currently being linked"]
#[doc = " against. Note that as of HAPI version 2.0, these enum values are"]
#[doc = " guaranteed never to change so you can reliably get this information from"]
#[doc = " any post-2.0 version of HAPI. The same goes for the actual"]
#[doc = " ::HAPI_GetEnvInt() API call."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_EnvIntType {
    HAPI_ENVINT_INVALID = -1,
    #[doc = " The three components of the Houdini version that HAPI is"]
    #[doc = " expecting to link against."]
    #[doc = " @{"]
    HAPI_ENVINT_VERSION_HOUDINI_MAJOR = 100,
    #[doc = " The three components of the Houdini version that HAPI is"]
    #[doc = " expecting to link against."]
    #[doc = " @{"]
    HAPI_ENVINT_VERSION_HOUDINI_MINOR = 110,
    #[doc = " The three components of the Houdini version that HAPI is"]
    #[doc = " expecting to link against."]
    #[doc = " @{"]
    HAPI_ENVINT_VERSION_HOUDINI_BUILD = 120,
    #[doc = " The three components of the Houdini version that HAPI is"]
    #[doc = " expecting to link against."]
    #[doc = " @{"]
    HAPI_ENVINT_VERSION_HOUDINI_PATCH = 130,
    #[doc = " The two components of the Houdini Engine (marketed) version."]
    #[doc = " @{"]
    HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MAJOR = 200,
    #[doc = " The two components of the Houdini Engine (marketed) version."]
    #[doc = " @{"]
    HAPI_ENVINT_VERSION_HOUDINI_ENGINE_MINOR = 210,
    #[doc = " This is a monotonously increasing API version number that can be used"]
    #[doc = " to lock against a certain API for compatibility purposes. Basically,"]
    #[doc = " when this number changes code compiled against the HAPI.h methods"]
    #[doc = " might no longer compile. Semantic changes to the methods will also"]
    #[doc = " cause this version to increase. This number will be reset to 0"]
    #[doc = " every time the Houdini Engine version is bumped."]
    HAPI_ENVINT_VERSION_HOUDINI_ENGINE_API = 220,
    #[doc = " This is a monotonously increasing API version number that can be used"]
    #[doc = " to lock against a certain API for compatibility purposes. Basically,"]
    #[doc = " when this number changes code compiled against the HAPI.h methods"]
    #[doc = " might no longer compile. Semantic changes to the methods will also"]
    #[doc = " cause this version to increase. This number will be reset to 0"]
    #[doc = " every time the Houdini Engine version is bumped."]
    HAPI_ENVINT_MAX = 221,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " This enum is to be used with ::HAPI_GetSessionEnvInt() to retrieve basic"]
#[doc = " session-specific information."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_SessionEnvIntType {
    HAPI_SESSIONENVINT_INVALID = -1,
    #[doc = " License Type. See ::HAPI_License."]
    HAPI_SESSIONENVINT_LICENSE = 100,
    #[doc = " License Type. See ::HAPI_License."]
    HAPI_SESSIONENVINT_MAX = 101,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " [HAPI_CacheProperty]"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_CacheProperty {
    #[doc = " Current memory usage in MB. Setting this to 0 invokes"]
    #[doc = " a cache clear."]
    HAPI_CACHEPROP_CURRENT = 0,
    #[doc = "< True if it actually has a minimum size."]
    HAPI_CACHEPROP_HAS_MIN = 1,
    #[doc = "< Min cache memory limit in MB."]
    HAPI_CACHEPROP_MIN = 2,
    #[doc = "< True if it actually has a maximum size."]
    HAPI_CACHEPROP_HAS_MAX = 3,
    #[doc = "< Max cache memory limit in MB."]
    HAPI_CACHEPROP_MAX = 4,
    #[doc = " How aggressive to cull memory. This only works for:"]
    #[doc = "     - ::HAPI_CACHE_COP_COOK where:"]
    #[doc = "         0   ->  Never reduce inactive cache."]
    #[doc = "         1   ->  Always reduce inactive cache."]
    #[doc = "     - ::HAPI_CACHE_OBJ where:"]
    #[doc = "         0   ->  Never enforce the max memory limit."]
    #[doc = "         1   ->  Always enforce the max memory limit."]
    #[doc = "     - ::HAPI_CACHE_SOP where:"]
    #[doc = "         0   ->  When to Unload = Never"]
    #[doc = "                 When to Limit Max Memory = Never"]
    #[doc = "         1-2 ->  When to Unload = Based on Flag"]
    #[doc = "                 When to Limit Max Memory = Never"]
    #[doc = "         3-4 ->  When to Unload = Based on Flag"]
    #[doc = "                 When to Limit Max Memory = Always"]
    #[doc = "         5   ->  When to Unload = Always"]
    #[doc = "                 When to Limit Max Memory = Always"]
    HAPI_CACHEPROP_CULL_LEVEL = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Type of sampling for heightfield"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_HeightFieldSampling {
    HAPI_HEIGHTFIELD_SAMPLING_CENTER = 0,
    HAPI_HEIGHTFIELD_SAMPLING_CORNER = 1,
}
impl HAPI_PDG_State {
    pub const HAPI_PDG_STATE_MAX_READY_STATE: HAPI_PDG_State = HAPI_PDG_State::HAPI_PDG_STATE_READY;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Used with PDG functions"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PDG_State {
    HAPI_PDG_STATE_READY = 0,
    HAPI_PDG_STATE_COOKING = 1,
    HAPI_PDG_STATE_MAX = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Used with PDG functions"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PDG_EventType {
    HAPI_PDG_EVENT_NULL = 0,
    HAPI_PDG_EVENT_WORKITEM_ADD = 1,
    HAPI_PDG_EVENT_WORKITEM_REMOVE = 2,
    HAPI_PDG_EVENT_WORKITEM_STATE_CHANGE = 3,
    HAPI_PDG_EVENT_WORKITEM_ADD_DEP = 4,
    HAPI_PDG_EVENT_WORKITEM_REMOVE_DEP = 5,
    HAPI_PDG_EVENT_WORKITEM_ADD_PARENT = 6,
    HAPI_PDG_EVENT_WORKITEM_REMOVE_PARENT = 7,
    HAPI_PDG_EVENT_NODE_CLEAR = 8,
    HAPI_PDG_EVENT_COOK_ERROR = 9,
    HAPI_PDG_EVENT_COOK_WARNING = 10,
    HAPI_PDG_EVENT_COOK_COMPLETE = 11,
    HAPI_PDG_EVENT_DIRTY_START = 12,
    HAPI_PDG_EVENT_DIRTY_STOP = 13,
    HAPI_PDG_EVENT_DIRTY_ALL = 14,
    HAPI_PDG_EVENT_UI_SELECT = 15,
    HAPI_PDG_EVENT_NODE_CREATE = 16,
    HAPI_PDG_EVENT_NODE_REMOVE = 17,
    HAPI_PDG_EVENT_NODE_RENAME = 18,
    HAPI_PDG_EVENT_NODE_CONNECT = 19,
    HAPI_PDG_EVENT_NODE_DISCONNECT = 20,
    HAPI_PDG_EVENT_WORKITEM_SET_INT = 21,
    HAPI_PDG_EVENT_WORKITEM_SET_FLOAT = 22,
    HAPI_PDG_EVENT_WORKITEM_SET_STRING = 23,
    HAPI_PDG_EVENT_WORKITEM_SET_FILE = 24,
    HAPI_PDG_EVENT_WORKITEM_SET_PYOBJECT = 25,
    HAPI_PDG_EVENT_WORKITEM_SET_GEOMETRY = 26,
    HAPI_PDG_EVENT_WORKITEM_MERGE = 27,
    HAPI_PDG_EVENT_WORKITEM_RESULT = 28,
    HAPI_PDG_EVENT_WORKITEM_PRIORITY = 29,
    HAPI_PDG_EVENT_COOK_START = 30,
    HAPI_PDG_EVENT_WORKITEM_ADD_STATIC_ANCESTOR = 31,
    HAPI_PDG_EVENT_WORKITEM_REMOVE_STATIC_ANCESTOR = 32,
    HAPI_PDG_EVENT_NODE_PROGRESS_UPDATE = 33,
    HAPI_PDG_EVENT_BATCH_ITEM_INITIALIZED = 34,
    HAPI_PDG_EVENT_ALL = 35,
    HAPI_PDG_EVENT_LOG = 36,
    HAPI_PDG_EVENT_SCHEDULER_ADDED = 37,
    HAPI_PDG_EVENT_SCHEDULER_REMOVED = 38,
    HAPI_PDG_EVENT_SET_SCHEDULER = 39,
    HAPI_PDG_EVENT_SERVICE_MANAGER_ALL = 40,
    HAPI_PDG_CONTEXT_EVENTS = 41,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Used with PDG functions"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HAPI_PDG_WorkitemState {
    HAPI_PDG_WORKITEM_UNDEFINED = 0,
    HAPI_PDG_WORKITEM_UNCOOKED = 1,
    HAPI_PDG_WORKITEM_WAITING = 2,
    HAPI_PDG_WORKITEM_SCHEDULED = 3,
    HAPI_PDG_WORKITEM_COOKING = 4,
    HAPI_PDG_WORKITEM_COOKED_SUCCESS = 5,
    HAPI_PDG_WORKITEM_COOKED_CACHE = 6,
    HAPI_PDG_WORKITEM_COOKED_FAIL = 7,
    HAPI_PDG_WORKITEM_COOKED_CANCEL = 8,
    HAPI_PDG_WORKITEM_DIRTY = 9,
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_Transform {
    pub position: [f32; 3usize],
    pub rotationQuaternion: [f32; 4usize],
    pub scale: [f32; 3usize],
    pub shear: [f32; 3usize],
    pub rstOrder: HAPI_RSTOrder,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_TransformEuler {
    pub position: [f32; 3usize],
    pub rotationEuler: [f32; 3usize],
    pub scale: [f32; 3usize],
    pub shear: [f32; 3usize],
    pub rotationOrder: HAPI_XYZOrder,
    pub rstOrder: HAPI_RSTOrder,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_Session {
    #[doc = " The type of session determines the which implementation will be"]
    #[doc = " used to communicate with the Houdini Engine library."]
    pub type_: HAPI_SessionType,
    #[doc = " Some session types support multiple simultaneous sessions. This means"]
    #[doc = " that each session needs to have a unique identifier."]
    pub id: HAPI_SessionId,
}
#[doc = " Options to configure a Thrift server being started from HARC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_ThriftServerOptions {
    #[doc = " Close the server automatically when all clients disconnect from it."]
    pub autoClose: HAPI_Bool,
    #[doc = " Timeout in milliseconds for waiting on the server to"]
    #[doc = " signal that it's ready to serve. If the server fails"]
    #[doc = " to signal within this time interval, the start server call fails"]
    #[doc = " and the server process is terminated."]
    pub timeoutMs: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_TimelineOptions {
    pub fps: f32,
    pub startTime: f32,
    pub endTime: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_AssetInfo {
    #[doc = " Use the node id to get the asset's parameters."]
    #[doc = " See @ref HAPI_Nodes_Basics."]
    pub nodeId: HAPI_NodeId,
    #[doc = " The objectNodeId differs from the regular nodeId in that for"]
    #[doc = " geometry based assets (SOPs) it will be the node id of the dummy"]
    #[doc = " object (OBJ) node instead of the asset node. For object based assets"]
    #[doc = " the objectNodeId will equal the nodeId. The reason the distinction"]
    #[doc = " exists is because transforms are always stored on the object node"]
    #[doc = " but the asset parameters may not be on the asset node if the asset"]
    #[doc = " is a geometry asset so we need both."]
    pub objectNodeId: HAPI_NodeId,
    #[doc = " It's possible to instantiate an asset without cooking it."]
    #[doc = " See @ref HAPI_Assets_Cooking."]
    pub hasEverCooked: HAPI_Bool,
    #[doc = "< Instance name (the label + a number)."]
    pub nameSH: HAPI_StringHandle,
    #[doc = "< This is what any end user should be shown."]
    pub labelSH: HAPI_StringHandle,
    #[doc = "< Path to the .otl library file."]
    pub filePathSH: HAPI_StringHandle,
    #[doc = "< User-defined asset version."]
    pub versionSH: HAPI_StringHandle,
    #[doc = "< Full asset name and namespace."]
    pub fullOpNameSH: HAPI_StringHandle,
    #[doc = "< Asset help marked-up text."]
    pub helpTextSH: HAPI_StringHandle,
    #[doc = "< Asset help URL."]
    pub helpURLSH: HAPI_StringHandle,
    #[doc = "< See @ref HAPI_Objects."]
    pub objectCount: ::std::os::raw::c_int,
    #[doc = "< See @ref HAPI_Handles."]
    pub handleCount: ::std::os::raw::c_int,
    #[doc = " Transform inputs exposed by the asset. For OBJ assets this is the"]
    #[doc = " number of transform inputs on the OBJ node. For SOP assets, this is"]
    #[doc = " the singular transform input on the dummy wrapper OBJ node."]
    #[doc = " See @ref HAPI_AssetInputs."]
    pub transformInputCount: ::std::os::raw::c_int,
    #[doc = " Geometry inputs exposed by the asset. For SOP assets this is"]
    #[doc = " the number of geometry inputs on the SOP node itself. OBJ assets"]
    #[doc = " will always have zero geometry inputs."]
    #[doc = " See @ref HAPI_AssetInputs."]
    pub geoInputCount: ::std::os::raw::c_int,
    #[doc = " Geometry outputs exposed by the asset. For SOP assets this is"]
    #[doc = " the number of geometry outputs on the SOP node itself. OBJ assets"]
    #[doc = " will always have zero geometry outputs."]
    #[doc = " See @ref HAPI_AssetInputs."]
    pub geoOutputCount: ::std::os::raw::c_int,
    #[doc = " For incremental updates. Indicates whether any of the assets's"]
    #[doc = " objects have changed. Refreshed only during an asset cook."]
    pub haveObjectsChanged: HAPI_Bool,
    #[doc = " For incremental updates. Indicates whether any of the asset's"]
    #[doc = " materials have changed. Refreshed only during an asset cook."]
    pub haveMaterialsChanged: HAPI_Bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_CookOptions {
    #[doc = " Normally, geos are split into parts in two different ways. First it"]
    #[doc = " is split by group and within each group it is split by primitive type."]
    #[doc = ""]
    #[doc = " For example, if you have a geo with group1 covering half of the mesh"]
    #[doc = " and volume1 and group2 covering the other half of the mesh, all of"]
    #[doc = " curve1, and volume2 you will end up with 5 parts. First two parts"]
    #[doc = " will be for the half-mesh of group1 and volume1, and the last three"]
    #[doc = " will cover group2."]
    #[doc = ""]
    #[doc = " This toggle lets you disable the splitting by group and just have"]
    #[doc = " the geo be split by primitive type alone. By default, this is true"]
    #[doc = " and therefore geos will be split by group and primitive type. If"]
    #[doc = " set to false, geos will only be split by primitive type."]
    pub splitGeosByGroup: HAPI_Bool,
    #[doc = " This toggle lets you enable the splitting by unique values"]
    #[doc = " of a specified attribute. By default, this is false and"]
    #[doc = " the geo be split as described above."]
    #[doc = " as described above. If this is set to true, and  splitGeosByGroup"]
    #[doc = " set to false, mesh geos will be split on attribute values"]
    #[doc = " The attribute name to split on must be created with HAPI_SetCustomString"]
    #[doc = " and then the splitAttrSH handle set on the struct."]
    pub splitGeosByAttribute: HAPI_Bool,
    pub splitAttrSH: HAPI_StringHandle,
    #[doc = " For meshes only, this is enforced by convexing the mesh. Use -1"]
    #[doc = " to avoid convexing at all and get some performance boost."]
    pub maxVerticesPerPrimitive: ::std::os::raw::c_int,
    #[doc = " For curves only."]
    #[doc = " If this is set to true, then all curves will be refined to a linear"]
    #[doc = " curve and you can no longer access the original CVs.  You can control"]
    #[doc = " the refinement detail via ::HAPI_CookOptions::curveRefineLOD."]
    #[doc = " If it's false, the curve type (NURBS, Bezier etc) will be left as is."]
    pub refineCurveToLinear: HAPI_Bool,
    #[doc = " Controls the number of divisions per unit distance when refining"]
    #[doc = " a curve to linear.  The default in Houdini is 8.0."]
    pub curveRefineLOD: f32,
    #[doc = " If this option is turned on, then we will recursively clear the"]
    #[doc = " errors and warnings (and messages) of all nodes before performing"]
    #[doc = " the cook."]
    pub clearErrorsAndWarnings: HAPI_Bool,
    #[doc = " Decide whether to recursively cook all templated geos or not."]
    pub cookTemplatedGeos: HAPI_Bool,
    #[doc = " Decide whether to split points by vertex attributes. This takes"]
    #[doc = " all vertex attributes and tries to copy them to their respective"]
    #[doc = " points. If two vertices have any difference in their attribute values,"]
    #[doc = " the corresponding point is split into two points. This is repeated"]
    #[doc = " until all the vertex attributes have been copied to the points."]
    #[doc = ""]
    #[doc = " With this option enabled, you can reduce the total number of vertices"]
    #[doc = " on a game engine side as sharing of attributes (like UVs) is optimized."]
    #[doc = " To make full use of this feature, you have to think of Houdini points"]
    #[doc = " as game engine vertices (sharable). With this option OFF (or before"]
    #[doc = " this feature existed) you had to map Houdini vertices to game engine"]
    #[doc = " vertices, to make sure all attribute values are accounted for."]
    pub splitPointsByVertexAttributes: HAPI_Bool,
    #[doc = " Choose how you want the cook to handle packed primitives."]
    #[doc = " The default is: ::HAPI_PACKEDPRIM_INSTANCING_MODE_DISABLED"]
    pub packedPrimInstancingMode: HAPI_PackedPrimInstancingMode,
    #[doc = " Choose which special part types should be handled. Unhandled special"]
    #[doc = " part types will just be refined to ::HAPI_PARTTYPE_MESH."]
    pub handleBoxPartTypes: HAPI_Bool,
    pub handleSpherePartTypes: HAPI_Bool,
    #[doc = " If enabled, sets the ::HAPI_PartInfo::hasChanged member during the"]
    #[doc = " cook.  If disabled, the member will always be true.  Checking for"]
    #[doc = " part changes can be expensive, so there is a potential performance"]
    #[doc = " gain when disabled."]
    pub checkPartChanges: HAPI_Bool,
    #[doc = " For internal use only. :)"]
    pub extraFlags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_NodeInfo {
    pub id: HAPI_NodeId,
    pub parentId: HAPI_NodeId,
    pub nameSH: HAPI_StringHandle,
    pub type_: HAPI_NodeType,
    #[doc = " Always true unless the asset's definition has changed due to loading"]
    #[doc = " a duplicate asset definition and from another OTL asset library"]
    #[doc = " file OR deleting the OTL asset library file used by this node's asset."]
    pub isValid: HAPI_Bool,
    #[doc = " Total number of cooks of this node."]
    pub totalCookCount: ::std::os::raw::c_int,
    #[doc = " Use this unique id to grab the OP_Node pointer for this node."]
    #[doc = " If you're linking against the C++ HDK, include the OP_Node.h header"]
    #[doc = " and call OP_Node::lookupNode()."]
    pub uniqueHoudiniNodeId: ::std::os::raw::c_int,
    #[doc = " This is the internal node path in the Houdini scene graph. This path"]
    #[doc = " is meant to be abstracted away for most client purposes but for"]
    #[doc = " advanced uses it can come in handy."]
    pub internalNodePathSH: HAPI_StringHandle,
    #[doc = " Total number of parameters this asset has exposed. Includes hidden"]
    #[doc = " parameters."]
    #[doc = " See @ref HAPI_Parameters."]
    pub parmCount: ::std::os::raw::c_int,
    #[doc = " Number of values. A single parameter may have more than one value so"]
    #[doc = " this number is more than or equal to ::HAPI_NodeInfo::parmCount."]
    #[doc = " @{"]
    pub parmIntValueCount: ::std::os::raw::c_int,
    pub parmFloatValueCount: ::std::os::raw::c_int,
    pub parmStringValueCount: ::std::os::raw::c_int,
    #[doc = " The total number of choices among all the combo box parameters."]
    #[doc = " See @ref HAPI_Parameters_ChoiceLists."]
    pub parmChoiceCount: ::std::os::raw::c_int,
    #[doc = " The number of child nodes. This is 0 for all nodes that are not"]
    #[doc = " node networks."]
    pub childNodeCount: ::std::os::raw::c_int,
    #[doc = " The number of inputs this specific node has."]
    pub inputCount: ::std::os::raw::c_int,
    #[doc = " The number of outputs this specific node has."]
    pub outputCount: ::std::os::raw::c_int,
    #[doc = " Nodes created via scripts or via ::HAPI_CreateNode() will be have"]
    #[doc = " this set to true. Only such nodes can be deleted using"]
    #[doc = " ::HAPI_DeleteNode()."]
    pub createdPostAssetLoad: HAPI_Bool,
    #[doc = " Indicates if this node will change over time"]
    pub isTimeDependent: HAPI_Bool,
}
#[doc = " @struct HAPI_ParmInfo"]
#[doc = ""]
#[doc = " Contains parameter information like name, label, type, and size."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_ParmInfo {
    #[doc = " The parent id points to the id of the parent parm"]
    #[doc = " of this parm. The parent parm is something like a folder."]
    pub id: HAPI_ParmId,
    #[doc = " Parameter id of the parent of this parameter."]
    pub parentId: HAPI_ParmId,
    #[doc = " Child index within its immediate parent parameter."]
    pub childIndex: ::std::os::raw::c_int,
    #[doc = " The HAPI type of the parm"]
    pub type_: HAPI_ParmType,
    #[doc = " The Houdini script-type of the parm"]
    pub scriptType: HAPI_PrmScriptType,
    #[doc = " Some parameter types require additional type information."]
    #[doc = "     - File path parameters will indicate what file extensions they"]
    #[doc = "       expect in a space-separated list of wild-cards. This is set"]
    #[doc = "       in the Operator Type Properties using the File Pattern"]
    #[doc = "       parameter property."]
    #[doc = "       For example, for filtering by PNG and JPG only: \"*.png *.jpg\""]
    pub typeInfoSH: HAPI_StringHandle,
    #[doc = " For the majority of parameter types permission will not be applicable."]
    #[doc = " For file path parameters these permissions will indicate how the"]
    #[doc = " asset plans to use the file: whether it will only read it, only write"]
    #[doc = " to it, or both. This is set in the Operator Type Properties using"]
    #[doc = " the Browse Mode parameter property."]
    pub permissions: HAPI_Permissions,
    #[doc = " Number of tags on this paramter."]
    pub tagCount: ::std::os::raw::c_int,
    #[doc = " Tuple size. For scalar parameters this value is 1, but for vector"]
    #[doc = " parameters this value can be greater.  For example, a 3 vector would"]
    #[doc = " have a size of 3. For folders and folder lists, this value is the"]
    #[doc = " number of children they own."]
    pub size: ::std::os::raw::c_int,
    #[doc = " Any ::HAPI_ParmType can be a choice list. If this is set to"]
    #[doc = " ::HAPI_CHOICELISTTYPE_NONE, than this parameter is NOT a choice list."]
    #[doc = " Otherwise, the parameter is a choice list of the indicated type."]
    #[doc = " See @ref HAPI_Parameters_ChoiceLists."]
    pub choiceListType: HAPI_ChoiceListType,
    #[doc = " Any ::HAPI_ParmType can be a choice list. If the parameter is a"]
    #[doc = " choice list, this tells you how many choices it currently has."]
    #[doc = " Note that some menu parameters can have a dynamic number of choices"]
    #[doc = " so it is important that this count is re-checked after every cook."]
    #[doc = " See @ref HAPI_Parameters_ChoiceLists."]
    pub choiceCount: ::std::os::raw::c_int,
    #[doc = " Note that folders are not real parameters in Houdini so they do not"]
    #[doc = " have names. The folder names given here are generated from the name"]
    #[doc = " of the folderlist (or switcher) parameter which is a parameter. The"]
    #[doc = " folderlist parameter simply defines how many of the \"next\" parameters"]
    #[doc = " belong to the first folder, how many of the parameters after that"]
    #[doc = " belong to the next folder, and so on. This means that folder names"]
    #[doc = " can change just by reordering the folders around so don't rely on"]
    #[doc = " them too much. The only guarantee here is that the folder names will"]
    #[doc = " be unique among all other parameter names."]
    pub nameSH: HAPI_StringHandle,
    #[doc = " The label string for the parameter"]
    pub labelSH: HAPI_StringHandle,
    #[doc = " If this parameter is a multiparm instance than the"]
    #[doc = " ::HAPI_ParmInfo::templateNameSH will be the hash-templated parm name,"]
    #[doc = " containing #'s for the parts of the name that use the instance number."]
    #[doc = " Compared to the ::HAPI_ParmInfo::nameSH, the ::HAPI_ParmInfo::nameSH"]
    #[doc = " will be the ::HAPI_ParmInfo::templateNameSH but with the #'s"]
    #[doc = " replaced by the instance number. For regular parms, the"]
    #[doc = " ::HAPI_ParmInfo::templateNameSH is identical to the"]
    #[doc = " ::HAPI_ParmInfo::nameSH."]
    pub templateNameSH: HAPI_StringHandle,
    #[doc = " The help string for this parameter"]
    pub helpSH: HAPI_StringHandle,
    #[doc = " Whether min/max exists for the parameter values."]
    #[doc = " @{"]
    pub hasMin: HAPI_Bool,
    pub hasMax: HAPI_Bool,
    pub hasUIMin: HAPI_Bool,
    pub hasUIMax: HAPI_Bool,
    #[doc = " Parameter value range, shared between int and float parameters."]
    #[doc = " @{"]
    pub min: f32,
    pub max: f32,
    pub UIMin: f32,
    pub UIMax: f32,
    #[doc = " Whether this parm should be hidden from the user entirely. This is"]
    #[doc = " mostly used to expose parameters as asset meta-data but not allow the"]
    #[doc = " user to directly modify them."]
    pub invisible: HAPI_Bool,
    #[doc = " Whether this parm should appear enabled or disabled."]
    pub disabled: HAPI_Bool,
    #[doc = " If true, it means this parameter doesn't actually exist on the node"]
    #[doc = " in Houdini but was added by Houdini Engine as a spare parameter."]
    #[doc = " This is just for your information. The behaviour of this parameter"]
    #[doc = " is not any different than a non-spare parameter."]
    pub spare: HAPI_Bool,
    #[doc = "< Whether this parm should be on the same line as"]
    #[doc = "< the next parm."]
    pub joinNext: HAPI_Bool,
    #[doc = "< Whether the label should be displayed."]
    pub labelNone: HAPI_Bool,
    #[doc = " The index to use to look into the values array in order to retrieve"]
    #[doc = " the actual value(s) of this parameter."]
    #[doc = " @{"]
    pub intValuesIndex: ::std::os::raw::c_int,
    pub floatValuesIndex: ::std::os::raw::c_int,
    pub stringValuesIndex: ::std::os::raw::c_int,
    pub choiceIndex: ::std::os::raw::c_int,
    #[doc = " If this is a ::HAPI_PARMTYPE_NODE, this tells you what node types"]
    #[doc = " this parameter accepts."]
    pub inputNodeType: HAPI_NodeType,
    #[doc = " The node input parameter could have another subtype filter specified,"]
    #[doc = " like \"Object: Geometry Only\". In this case, this value will specify"]
    #[doc = " that extra filter. If the filter demands a node that HAPI does not"]
    #[doc = " support, both this and ::HAPI_ParmInfo::inputNodeType will be set to"]
    #[doc = " NONE as such a node is not settable through HAPI."]
    pub inputNodeFlag: HAPI_NodeFlags,
    #[doc = " See @ref HAPI_Parameters_MultiParms."]
    #[doc = " @{"]
    pub isChildOfMultiParm: HAPI_Bool,
    #[doc = "< The index of the instance in the multiparm."]
    pub instanceNum: ::std::os::raw::c_int,
    #[doc = "< The number of parms in a multiparm instance."]
    pub instanceLength: ::std::os::raw::c_int,
    #[doc = "< The number of instances in a multiparm."]
    pub instanceCount: ::std::os::raw::c_int,
    #[doc = " First instance's ::HAPI_ParmInfo::instanceNum. Either 0 or 1."]
    pub instanceStartOffset: ::std::os::raw::c_int,
    pub rampType: HAPI_RampType,
    #[doc = " Provides the raw condition string which is used to evaluate the"]
    #[doc = " the visibility of a parm"]
    pub visibilityConditionSH: HAPI_StringHandle,
    #[doc = " Provides the raw condition string which is used to evalute whether"]
    #[doc = " a parm is enabled or disabled"]
    pub disabledConditionSH: HAPI_StringHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_ParmChoiceInfo {
    pub parentParmId: HAPI_ParmId,
    pub labelSH: HAPI_StringHandle,
    #[doc = " This evaluates to the value of the token associated with the label"]
    #[doc = " applies to string menus only."]
    pub valueSH: HAPI_StringHandle,
}
#[doc = " @struct HAPI_HandleInfo"]
#[doc = ""]
#[doc = " Contains handle information such as the type of handle"]
#[doc = " (translate, rotate, scale, softxform ...etc) and the number of"]
#[doc = " parameters the current handle is bound to."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_HandleInfo {
    pub nameSH: HAPI_StringHandle,
    pub typeNameSH: HAPI_StringHandle,
    pub bindingsCount: ::std::os::raw::c_int,
}
#[doc = " @struct HAPI_HandleBindingInfo"]
#[doc = ""]
#[doc = " Contains binding information that maps the handle parameter to"]
#[doc = " the asset parameter. The index is only used for int and float vector"]
#[doc = " and colour parms."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_HandleBindingInfo {
    pub handleParmNameSH: HAPI_StringHandle,
    pub assetParmNameSH: HAPI_StringHandle,
    pub assetParmId: HAPI_ParmId,
    pub assetParmIndex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_ObjectInfo {
    pub nameSH: HAPI_StringHandle,
    #[doc = " (deprecated)"]
    pub objectInstancePathSH: HAPI_StringHandle,
    #[doc = " For incremental updates. Indicates whether the object's transform"]
    #[doc = " has changed. Refreshed only during an asset cook."]
    pub hasTransformChanged: HAPI_Bool,
    #[doc = " For incremental updates. Indicates whether any of the object's"]
    #[doc = " geometry nodes have changed. Refreshed only during an asset cook."]
    pub haveGeosChanged: HAPI_Bool,
    #[doc = " Whether the object is hidden and should not be shown. Some objects"]
    #[doc = " should be hidden but still brought into the host environment, for"]
    #[doc = " example those used only for instancing."]
    #[doc = " See @ref HAPI_Instancing."]
    pub isVisible: HAPI_Bool,
    #[doc = " See @ref HAPI_Instancing."]
    pub isInstancer: HAPI_Bool,
    #[doc = " Determine if this object is being instanced. Normally, this implies"]
    #[doc = " that while this object may not be visible, it should still be"]
    #[doc = " brought into the host application because it is needed by an instancer."]
    #[doc = " See @ref HAPI_Instancing."]
    pub isInstanced: HAPI_Bool,
    #[doc = " (deprecated) The number of geometries under this object. For those familiar"]
    #[doc = " with Houdini, this number will always include the one visible SOP and any"]
    #[doc = " SOPs that were exposed as \"editable\" or \"templated\"."]
    #[doc = " See @ref HAPI_Geos."]
    pub geoCount: ::std::os::raw::c_int,
    #[doc = " Use the node id to get the node's parameters."]
    #[doc = " Using the HDK, you can also get the raw node C++ pointer for this"]
    #[doc = " object's internal node."]
    #[doc = " See @ref HAPI_Nodes_Basics."]
    pub nodeId: HAPI_NodeId,
    #[doc = " If the object is an instancer, this variable gives the object id of"]
    #[doc = " the object that should be instanced."]
    #[doc = " See @ref HAPI_Instancing."]
    pub objectToInstanceId: HAPI_NodeId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_GeoInfo {
    pub type_: HAPI_GeoType,
    pub nameSH: HAPI_StringHandle,
    #[doc = " Use the node id to get the node's parameters."]
    #[doc = " Using the HDK, you can also get the raw node C++ pointer for this"]
    #[doc = " object's internal node."]
    pub nodeId: HAPI_NodeId,
    #[doc = " Whether the SOP node has been exposed by dragging it into the"]
    #[doc = " editable nodes section of the asset definition."]
    pub isEditable: HAPI_Bool,
    #[doc = " Has the templated flag turned on which means \"expose as read-only\"."]
    pub isTemplated: HAPI_Bool,
    #[doc = " Final Result (Display SOP)."]
    pub isDisplayGeo: HAPI_Bool,
    #[doc = " For incremental updates."]
    pub hasGeoChanged: HAPI_Bool,
    #[doc = " (deprecated) This variable is deprecated and should no longer be used."]
    #[doc = " Materials are now separate from parts. They are maintained at the"]
    #[doc = " asset level so you only need to check if the material itself has"]
    #[doc = " changed via ::HAPI_MaterialInfo::hasChanged instead of the material"]
    #[doc = " on the part."]
    pub hasMaterialChanged: HAPI_Bool,
    #[doc = " Groups."]
    #[doc = " @{"]
    pub pointGroupCount: ::std::os::raw::c_int,
    pub primitiveGroupCount: ::std::os::raw::c_int,
    #[doc = " Total number of parts this geometry contains."]
    #[doc = " See @ref HAPI_Parts."]
    pub partCount: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_PartInfo {
    pub id: HAPI_PartId,
    pub nameSH: HAPI_StringHandle,
    pub type_: HAPI_PartType,
    pub faceCount: ::std::os::raw::c_int,
    pub vertexCount: ::std::os::raw::c_int,
    #[doc = "< Number of points. Note that this is NOT the number"]
    #[doc = "< of \"positions\" as \"points\" may imply. If your"]
    #[doc = "< geometry has 3 points then set this to 3 and not 3*3."]
    pub pointCount: ::std::os::raw::c_int,
    pub attributeCounts: [::std::os::raw::c_int; 4usize],
    #[doc = " If this is true, don't display this part. Load its data but then"]
    #[doc = " instance it where the corresponding instancer part tells you to"]
    #[doc = " instance it."]
    pub isInstanced: HAPI_Bool,
    #[doc = " The number of parts that this instancer part is instancing."]
    #[doc = " For example, if we're instancing a curve and a box, they would come"]
    #[doc = " across as two parts, hence this count would be two."]
    #[doc = " Call ::HAPI_GetInstancedPartIds() to get the list of ::HAPI_PartId's."]
    pub instancedPartCount: ::std::os::raw::c_int,
    #[doc = " The number of instances that this instancer part is instancing."]
    #[doc = " Using the same example as with ::HAPI_PartInfo::instancedPartCount,"]
    #[doc = " if I'm instancing the merge of a curve and a box 5 times, this count"]
    #[doc = " would be 5. To be clear, all instanced parts are instanced the same"]
    #[doc = " number of times and with the same transform for each instance."]
    #[doc = " Call ::HAPI_GetInstancerPartTransforms() to get the transform of"]
    #[doc = " each instance."]
    pub instanceCount: ::std::os::raw::c_int,
    #[doc = " If this is false, the underlying attribute data appear to match that of"]
    #[doc = " the previous cook.  In this case you may be able to re-used marshaled"]
    #[doc = " data from the previous cook."]
    pub hasChanged: HAPI_Bool,
}
#[doc = " See @ref HAPI_Attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_AttributeInfo {
    pub exists: HAPI_Bool,
    pub owner: HAPI_AttributeOwner,
    pub storage: HAPI_StorageType,
    #[doc = " When converting from the Houdini native GA geometry format to the"]
    #[doc = " GT geometry format HAPI uses, some attributes might change owners."]
    #[doc = " For example, in Houdini GA curves can have points shared by"]
    #[doc = " vertices but the GT format only supports curve vertices"]
    #[doc = " (no points). This means that if you had point attributes on a curve"]
    #[doc = " in Houdini, when it comes out of HAPI those point attributes will now"]
    #[doc = " be vertex attributes. In this case, the ::HAPI_AttributeInfo::owner"]
    #[doc = " will be set to ::HAPI_ATTROWNER_VERTEX but the"]
    #[doc = " ::HAPI_AttributeInfo::originalOwner will be ::HAPI_ATTROWNER_POINT."]
    pub originalOwner: HAPI_AttributeOwner,
    #[doc = " Number of attributes. This count will match the number of values"]
    #[doc = " given the owner. For example, if the owner is ::HAPI_ATTROWNER_VERTEX"]
    #[doc = " this count will be the same as the ::HAPI_PartInfo::vertexCount."]
    #[doc = " To be clear, this is not the number of values in the attribute, rather"]
    #[doc = " it is the number of attributes. If your geometry has three 3D points"]
    #[doc = " then this count will be 3 (not 3*3) while the"]
    #[doc = " ::HAPI_AttributeInfo::tupleSize will be 3."]
    pub count: ::std::os::raw::c_int,
    #[doc = " Number of values per attribute."]
    #[doc = " Note that this is NOT the memory size of the attribute. It is the"]
    #[doc = " number of values per attributes. Multiplying this by the"]
    #[doc = " size of the ::HAPI_AttributeInfo::storage will give you the memory"]
    #[doc = " size per attribute."]
    pub tupleSize: ::std::os::raw::c_int,
    #[doc = " Total number of elements for an array attribute."]
    #[doc = " An array attribute can be thought of as a 2 dimensional array where"]
    #[doc = " the 2nd dimension can vary in size for each element in the 1st"]
    #[doc = " dimension. Therefore this returns the total number of values in"]
    #[doc = " the entire array."]
    #[doc = " This should be used to determine the total storage"]
    #[doc = " size needed by multiplying with ::HAPI_AttributeInfo::storage."]
    #[doc = " Note that this will be 0 for a non-array attribute."]
    pub totalArrayElements: HAPI_Int64,
    #[doc = " Attribute type info"]
    #[doc = " This is used to help identify the type of data stored in an attribute."]
    #[doc = " Using the type is recommended over using just an attribute's name to identify"]
    #[doc = " its purpose."]
    pub typeInfo: HAPI_AttributeTypeInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_MaterialInfo {
    #[doc = " This is the HAPI node id for the SHOP node this material is attached"]
    #[doc = " to. Use it to get access to the parameters (which contain the"]
    #[doc = " texture paths)."]
    #[doc = " IMPORTANT: When the ::HAPI_MaterialInfo::hasChanged is true this"]
    #[doc = " @p nodeId could have changed. Do not assume ::HAPI_MaterialInfo::nodeId"]
    #[doc = " will never change for a specific material."]
    pub nodeId: HAPI_NodeId,
    pub exists: HAPI_Bool,
    pub hasChanged: HAPI_Bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_ImageFileFormat {
    pub nameSH: HAPI_StringHandle,
    pub descriptionSH: HAPI_StringHandle,
    pub defaultExtensionSH: HAPI_StringHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_ImageInfo {
    #[doc = " Unlike the other members of this struct changing imageFileFormatNameSH"]
    #[doc = " and giving this struct back to HAPI_SetImageInfo() nothing will happen."]
    #[doc = " Use this member variable to derive which image file format will be used"]
    #[doc = " by the HAPI_ExtractImageTo...() functions if called with"]
    #[doc = " image_file_format_name set to NULL. This way, you can decide whether"]
    #[doc = " to ask for a file format conversion (slower) or not (faster)."]
    pub imageFileFormatNameSH: HAPI_StringHandle,
    pub xRes: ::std::os::raw::c_int,
    pub yRes: ::std::os::raw::c_int,
    pub dataFormat: HAPI_ImageDataFormat,
    #[doc = "< ex: true = RGBRGBRGB, false = RRRGGGBBB"]
    pub interleaved: HAPI_Bool,
    pub packing: HAPI_ImagePacking,
    #[doc = " Adjust the gamma of the image. For anything less than"]
    #[doc = " ::HAPI_IMAGE_DATA_INT16, you probably want to leave this as 2.2."]
    pub gamma: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_Keyframe {
    pub time: f32,
    pub value: f32,
    pub inTangent: f32,
    pub outTangent: f32,
}
#[doc = " @struct HAPI_VolumeInfo"]
#[doc = ""]
#[doc = " This represents a volume primitive but does not contain the actual voxel"]
#[doc = " values, which can be retrieved on a per-tile basis."]
#[doc = ""]
#[doc = " See @ref HAPI_Volumes."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_VolumeInfo {
    pub nameSH: HAPI_StringHandle,
    pub type_: HAPI_VolumeType,
    #[doc = " Each voxel is identified with an index. The indices will range"]
    #[doc = " between:"]
    #[doc = " [ ( minX, minY, minZ ), ( minX+xLength, minY+yLength, minZ+zLength ) )"]
    #[doc = " @{"]
    pub xLength: ::std::os::raw::c_int,
    pub yLength: ::std::os::raw::c_int,
    pub zLength: ::std::os::raw::c_int,
    pub minX: ::std::os::raw::c_int,
    pub minY: ::std::os::raw::c_int,
    pub minZ: ::std::os::raw::c_int,
    #[doc = " Number of values per voxel."]
    #[doc = " The tuple size field is 1 for scalars and 3 for vector data."]
    pub tupleSize: ::std::os::raw::c_int,
    #[doc = " Can be either ::HAPI_STORAGETYPE_INT or ::HAPI_STORAGETYPE_FLOAT."]
    pub storage: HAPI_StorageType,
    #[doc = " The dimensions of each tile."]
    #[doc = " This can be 8 or 16, denoting an 8x8x8 or 16x16x16 tiles."]
    pub tileSize: ::std::os::raw::c_int,
    #[doc = " The transform of the volume with respect to the lengths."]
    #[doc = " The volume may be positioned anywhere in space."]
    pub transform: HAPI_Transform,
    #[doc = " Denotes special situations where the volume tiles are not perfect"]
    #[doc = " cubes, but are tapered instead."]
    pub hasTaper: HAPI_Bool,
    #[doc = " If there is taper involved, denotes the amount of taper involved."]
    #[doc = " @{"]
    pub xTaper: f32,
    pub yTaper: f32,
}
#[doc = " @struct HAPI_VolumeTileInfo"]
#[doc = ""]
#[doc = " A HAPI_VolumeTileInfo represents an cube subarray of the volume."]
#[doc = " The size of each dimension is HAPI_VoluemInfo::tileSize"]
#[doc = " bbox [(minX, minY, minZ), (minX+tileSize, minY+tileSize, minZ+tileSize))"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_VolumeTileInfo {
    pub minX: ::std::os::raw::c_int,
    pub minY: ::std::os::raw::c_int,
    pub minZ: ::std::os::raw::c_int,
    pub isValid: HAPI_Bool,
}
#[doc = " @struct HAPI_VolumeVisualInfo"]
#[doc = ""]
#[doc = " Describes the visual settings of a volume."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_VolumeVisualInfo {
    pub type_: HAPI_VolumeVisualType,
    pub iso: f32,
    pub density: f32,
}
#[doc = " @struct HAPI_CurveInfo"]
#[doc = ""]
#[doc = " This represents the meta-data associated with a curve mesh (a number"]
#[doc = " of curves of the same type)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_CurveInfo {
    pub curveType: HAPI_CurveType,
    #[doc = "< The number of curves contained in this curve mesh."]
    pub curveCount: ::std::os::raw::c_int,
    #[doc = "< The number of control vertices (CVs) for all curves."]
    pub vertexCount: ::std::os::raw::c_int,
    #[doc = "< The number of knots for all curves."]
    pub knotCount: ::std::os::raw::c_int,
    pub isPeriodic: HAPI_Bool,
    pub isRational: HAPI_Bool,
    #[doc = "< Order of 1 is invalid. 0 means there is a varying order."]
    pub order: ::std::os::raw::c_int,
    #[doc = "< Whether the curve has knots."]
    pub hasKnots: HAPI_Bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_BoxInfo {
    pub center: [f32; 3usize],
    pub size: [f32; 3usize],
    pub rotation: [f32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_SphereInfo {
    pub center: [f32; 3usize],
    pub radius: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_PDG_EventInfo {
    pub nodeId: HAPI_NodeId,
    #[doc = " id of related node"]
    pub workitemId: HAPI_PDG_WorkitemId,
    #[doc = " id of related workitem"]
    pub dependencyId: HAPI_PDG_WorkitemId,
    #[doc = " id of related workitem dependency"]
    pub currentState: ::std::os::raw::c_int,
    #[doc = " (HAPI_PDG_WorkItemState) value of current state for state change"]
    pub lastState: ::std::os::raw::c_int,
    #[doc = " (HAPI_PDG_WorkItemState) value of last state for state change"]
    pub eventType: ::std::os::raw::c_int,
    #[doc = " (HAPI_PDG_EventType) event type"]
    pub msgSH: HAPI_StringHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_PDG_WorkitemInfo {
    pub index: ::std::os::raw::c_int,
    #[doc = " index of the workitem"]
    pub numResults: ::std::os::raw::c_int,
    #[doc = " number of results reported"]
    pub nameSH: HAPI_StringHandle,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_PDG_WorkitemResultInfo {
    pub resultSH: ::std::os::raw::c_int,
    #[doc = " result string data"]
    pub resultTagSH: ::std::os::raw::c_int,
    #[doc = " result tag"]
    pub resultHash: HAPI_Int64,
}
#[doc = " @struct HAPI_Viewport"]
#[doc = ""]
#[doc = " Contains the information for synchronizing viewport between Houdini"]
#[doc = " and other applications. When SessionSync is enabled, Houdini will"]
#[doc = " update this struct with its viewport state. It will also update"]
#[doc = " its own viewport if this struct has changed."]
#[doc = " The data stored is in Houdini's right-handed Y-up coordinate system."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_Viewport {
    #[doc = " The world position of the viewport camera's pivot."]
    pub position: [f32; 3usize],
    #[doc = " The direction of the viewport camera stored as a quaternion."]
    pub rotationQuaternion: [f32; 4usize],
    #[doc = " The offset from the pivot to the viewport camera's"]
    #[doc = " actual world position."]
    pub offset: f32,
}
#[doc = " @struct HAPI_SessionSyncInfo"]
#[doc = ""]
#[doc = " Contains the information for synchronizing general SessionSync"]
#[doc = " state between Houdini and other applications. When SessionSync"]
#[doc = " is enabled, Houdini will update this struct with its state."]
#[doc = " It will also update its internal state if this struct has"]
#[doc = " changed."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAPI_SessionSyncInfo {
    #[doc = " Specifies whether Houdini's current time is used for Houdini Engine"]
    #[doc = " cooks. This is automatically enabled in SessionSync where"]
    #[doc = " Houdini's viewport forces cooks to use Houdini's current time."]
    #[doc = " This is disabled in non-SessionSync mode, but can be toggled to"]
    #[doc = " override default behaviour."]
    pub cookUsingHoudiniTime: HAPI_Bool,
    #[doc = " Specifies whether viewport synchronization is enabled. If enabled,"]
    #[doc = " in SessionSync, Houdini will update its own viewport using"]
    #[doc = " ::HAPI_Viewport."]
    pub syncViewport: HAPI_Bool,
}
extern "C" {
    pub fn HAPI_TimelineOptions_Init(in_: *mut HAPI_TimelineOptions);
}
extern "C" {
    pub fn HAPI_TimelineOptions_Create() -> HAPI_TimelineOptions;
}
extern "C" {
    pub fn HAPI_AssetInfo_Init(in_: *mut HAPI_AssetInfo);
}
extern "C" {
    pub fn HAPI_AssetInfo_Create() -> HAPI_AssetInfo;
}
extern "C" {
    pub fn HAPI_CookOptions_Init(in_: *mut HAPI_CookOptions);
}
extern "C" {
    pub fn HAPI_CookOptions_Create() -> HAPI_CookOptions;
}
extern "C" {
    pub fn HAPI_CookOptions_AreEqual(
        left: *const HAPI_CookOptions,
        right: *const HAPI_CookOptions,
    ) -> HAPI_Bool;
}
extern "C" {
    pub fn HAPI_NodeInfo_Init(in_: *mut HAPI_NodeInfo);
}
extern "C" {
    pub fn HAPI_NodeInfo_Create() -> HAPI_NodeInfo;
}
extern "C" {
    #[doc = " Clears the struct to default values."]
    pub fn HAPI_ParmInfo_Init(in_: *mut HAPI_ParmInfo);
}
extern "C" {
    #[doc = " Creates a struct with default values and returns it."]
    pub fn HAPI_ParmInfo_Create() -> HAPI_ParmInfo;
}
extern "C" {
    #[doc = " Convenience function that checks on the value of the ::HAPI_ParmInfo::type"]
    #[doc = " field to tell you the underlying data type."]
    #[doc = " @{"]
    pub fn HAPI_ParmInfo_IsInt(in_: *const HAPI_ParmInfo) -> HAPI_Bool;
}
extern "C" {
    pub fn HAPI_ParmInfo_IsFloat(in_: *const HAPI_ParmInfo) -> HAPI_Bool;
}
extern "C" {
    pub fn HAPI_ParmInfo_IsString(in_: *const HAPI_ParmInfo) -> HAPI_Bool;
}
extern "C" {
    pub fn HAPI_ParmInfo_IsPath(in_: *const HAPI_ParmInfo) -> HAPI_Bool;
}
extern "C" {
    pub fn HAPI_ParmInfo_IsNode(in_: *const HAPI_ParmInfo) -> HAPI_Bool;
}
extern "C" {
    #[doc = " Parameter has no underlying No data type. Examples of this are UI items"]
    #[doc = " such as folder lists and separators."]
    pub fn HAPI_ParmInfo_IsNonValue(in_: *const HAPI_ParmInfo) -> HAPI_Bool;
}
extern "C" {
    #[doc = " Convenience function. If the parameter can be represented by this data"]
    #[doc = " type, it returns ::HAPI_ParmInfo::size, and zero otherwise."]
    #[doc = " @{"]
    pub fn HAPI_ParmInfo_GetIntValueCount(in_: *const HAPI_ParmInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAPI_ParmInfo_GetFloatValueCount(in_: *const HAPI_ParmInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAPI_ParmInfo_GetStringValueCount(in_: *const HAPI_ParmInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @}"]
    pub fn HAPI_ParmChoiceInfo_Init(in_: *mut HAPI_ParmChoiceInfo);
}
extern "C" {
    pub fn HAPI_ParmChoiceInfo_Create() -> HAPI_ParmChoiceInfo;
}
extern "C" {
    pub fn HAPI_HandleInfo_Init(in_: *mut HAPI_HandleInfo);
}
extern "C" {
    pub fn HAPI_HandleInfo_Create() -> HAPI_HandleInfo;
}
extern "C" {
    pub fn HAPI_HandleBindingInfo_Init(in_: *mut HAPI_HandleBindingInfo);
}
extern "C" {
    pub fn HAPI_HandleBindingInfo_Create() -> HAPI_HandleBindingInfo;
}
extern "C" {
    pub fn HAPI_ObjectInfo_Init(in_: *mut HAPI_ObjectInfo);
}
extern "C" {
    pub fn HAPI_ObjectInfo_Create() -> HAPI_ObjectInfo;
}
extern "C" {
    pub fn HAPI_GeoInfo_Init(in_: *mut HAPI_GeoInfo);
}
extern "C" {
    pub fn HAPI_GeoInfo_Create() -> HAPI_GeoInfo;
}
extern "C" {
    pub fn HAPI_GeoInfo_GetGroupCountByType(
        in_: *mut HAPI_GeoInfo,
        type_: HAPI_GroupType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAPI_PartInfo_Init(in_: *mut HAPI_PartInfo);
}
extern "C" {
    pub fn HAPI_PartInfo_Create() -> HAPI_PartInfo;
}
extern "C" {
    pub fn HAPI_PartInfo_GetElementCountByAttributeOwner(
        in_: *mut HAPI_PartInfo,
        owner: HAPI_AttributeOwner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAPI_PartInfo_GetElementCountByGroupType(
        in_: *mut HAPI_PartInfo,
        type_: HAPI_GroupType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAPI_PartInfo_GetAttributeCountByOwner(
        in_: *mut HAPI_PartInfo,
        owner: HAPI_AttributeOwner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAPI_AttributeInfo_Init(in_: *mut HAPI_AttributeInfo);
}
extern "C" {
    pub fn HAPI_AttributeInfo_Create() -> HAPI_AttributeInfo;
}
extern "C" {
    pub fn HAPI_MaterialInfo_Init(in_: *mut HAPI_MaterialInfo);
}
extern "C" {
    pub fn HAPI_MaterialInfo_Create() -> HAPI_MaterialInfo;
}
extern "C" {
    pub fn HAPI_ImageFileFormat_Init(in_: *mut HAPI_ImageFileFormat);
}
extern "C" {
    pub fn HAPI_ImageFileFormat_Create() -> HAPI_ImageFileFormat;
}
extern "C" {
    pub fn HAPI_ImageInfo_Init(in_: *mut HAPI_ImageInfo);
}
extern "C" {
    pub fn HAPI_ImageInfo_Create() -> HAPI_ImageInfo;
}
extern "C" {
    pub fn HAPI_Keyframe_Init(in_: *mut HAPI_Keyframe);
}
extern "C" {
    pub fn HAPI_Keyframe_Create() -> HAPI_Keyframe;
}
extern "C" {
    pub fn HAPI_VolumeInfo_Init(in_: *mut HAPI_VolumeInfo);
}
extern "C" {
    pub fn HAPI_VolumeInfo_Create() -> HAPI_VolumeInfo;
}
extern "C" {
    pub fn HAPI_VolumeTileInfo_Init(in_: *mut HAPI_VolumeTileInfo);
}
extern "C" {
    pub fn HAPI_VolumeTileInfo_Create() -> HAPI_VolumeTileInfo;
}
extern "C" {
    pub fn HAPI_CurveInfo_Init(in_: *mut HAPI_CurveInfo);
}
extern "C" {
    pub fn HAPI_CurveInfo_Create() -> HAPI_CurveInfo;
}
extern "C" {
    pub fn HAPI_Transform_Init(in_: *mut HAPI_Transform);
}
extern "C" {
    pub fn HAPI_Transform_Create() -> HAPI_Transform;
}
extern "C" {
    pub fn HAPI_TransformEuler_Init(in_: *mut HAPI_TransformEuler);
}
extern "C" {
    pub fn HAPI_TransformEuler_Create() -> HAPI_TransformEuler;
}
extern "C" {
    pub fn HAPI_Viewport_Init(in_: *mut HAPI_Viewport);
}
extern "C" {
    pub fn HAPI_Viewport_Create() -> HAPI_Viewport;
}
extern "C" {
    pub fn HAPI_SessionSyncInfo_Init(in_: *mut HAPI_SessionSyncInfo);
}
extern "C" {
    pub fn HAPI_SessionSyncInfo_Create() -> HAPI_SessionSyncInfo;
}
extern "C" {
    #[doc = " @brief  Creates a new in-process session.  There can only be"]
    #[doc = "         one such session per host process."]
    #[doc = ""]
    #[doc = " @param[out]     session"]
    #[doc = "                 A ::HAPI_Session struct to receive the session id,"]
    #[doc = "                 in this case always 0."]
    #[doc = ""]
    pub fn HAPI_CreateInProcessSession(session: *mut HAPI_Session) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Starts a Thrift RPC server process on the local host serving"]
    #[doc = "         clients on a TCP socket and waits for it to start serving."]
    #[doc = "         It is safe to create an RPC session on local host using the"]
    #[doc = "         specified port after this call succeeds."]
    #[doc = ""]
    #[doc = " @param[in]      options"]
    #[doc = "                 Options to configure the server being started."]
    #[doc = ""]
    #[doc = " @param[in]      port"]
    #[doc = "                 The TCP socket to create on the server."]
    #[doc = ""]
    #[doc = " @param[out]     process_id"]
    #[doc = "                 The process id of the server, if started successfully."]
    #[doc = ""]
    pub fn HAPI_StartThriftSocketServer(
        options: *const HAPI_ThriftServerOptions,
        port: ::std::os::raw::c_int,
        process_id: *mut HAPI_ProcessId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates a Thrift RPC session using a TCP socket as transport."]
    #[doc = ""]
    #[doc = " @param[out]     session"]
    #[doc = "                 A ::HAPI_Session struct to receive the unique session id"]
    #[doc = "                 of the new session."]
    #[doc = ""]
    #[doc = " @param[in]      host_name"]
    #[doc = "                 The name of the server host."]
    #[doc = ""]
    #[doc = " @param[in]      port"]
    #[doc = "                 The server port to connect to."]
    #[doc = ""]
    pub fn HAPI_CreateThriftSocketSession(
        session: *mut HAPI_Session,
        host_name: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Starts a Thrift RPC server process on the local host serving"]
    #[doc = "         clients on a Windows named pipe or a Unix domain socket and"]
    #[doc = "         waits for it to start serving. It is safe to create an RPC"]
    #[doc = "         session using the specified pipe or socket after this call"]
    #[doc = "         succeeds."]
    #[doc = ""]
    #[doc = " @param[in]      options"]
    #[doc = "                 Options to configure the server being started."]
    #[doc = ""]
    #[doc = " @param[in]      pipe_name"]
    #[doc = "                 The name of the pipe or socket."]
    #[doc = ""]
    #[doc = " @param[out]     process_id"]
    #[doc = "                 The process id of the server, if started successfully."]
    #[doc = ""]
    pub fn HAPI_StartThriftNamedPipeServer(
        options: *const HAPI_ThriftServerOptions,
        pipe_name: *const ::std::os::raw::c_char,
        process_id: *mut HAPI_ProcessId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates a Thrift RPC session using a Windows named pipe"]
    #[doc = "         or a Unix domain socket as transport."]
    #[doc = ""]
    #[doc = " @param[out]     session"]
    #[doc = "                 A ::HAPI_Session struct to receive the unique session id"]
    #[doc = "                 of the new session."]
    #[doc = ""]
    #[doc = " @param[in]      pipe_name"]
    #[doc = "                 The name of the pipe or socket."]
    #[doc = ""]
    pub fn HAPI_CreateThriftNamedPipeSession(
        session: *mut HAPI_Session,
        pipe_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Binds a new implementation DLL to one of the custom session"]
    #[doc = "         slots."]
    #[doc = ""]
    #[doc = " @param[in]      session_type"]
    #[doc = "                 Which custom implementation slot to bind the"]
    #[doc = "                 DLL to. Must be one of ::HAPI_SESSION_CUSTOM1,"]
    #[doc = "                 ::HAPI_SESSION_CUSTOM2, or ::HAPI_SESSION_CUSTOM3."]
    #[doc = ""]
    #[doc = " @param[in]      dll_path"]
    #[doc = "                 The path to the custom implementation DLL."]
    #[doc = ""]
    pub fn HAPI_BindCustomImplementation(
        session_type: HAPI_SessionType,
        dll_path: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates a new session using a custom implementation."]
    #[doc = "         Note that the implementation DLL must already have"]
    #[doc = "         been bound to the session via calling"]
    #[doc = "         ::HAPI_BindCustomImplementation()."]
    #[doc = ""]
    #[doc = " @param[in]      session_type"]
    #[doc = "                 session_type indicates which custom session"]
    #[doc = "                 slot to create the session on."]
    #[doc = ""]
    #[doc = " @param[in,out]  session_info"]
    #[doc = "                 Any data required by the custom implementation to"]
    #[doc = "                 create its session."]
    #[doc = ""]
    #[doc = " @param[out]     session"]
    #[doc = "                 A ::HAPI_Session struct to receive the session id,"]
    #[doc = "                 The sessionType parameter of the struct should"]
    #[doc = "                 also match the session_type parameter passed in."]
    #[doc = ""]
    pub fn HAPI_CreateCustomSession(
        session_type: HAPI_SessionType,
        session_info: *mut ::std::os::raw::c_void,
        session: *mut HAPI_Session,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Checks whether the session identified by ::HAPI_Session::id is"]
    #[doc = "         a valid session opened in the implementation identified by"]
    #[doc = "         ::HAPI_Session::type."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The ::HAPI_Session to check."]
    #[doc = ""]
    #[doc = " @return         ::HAPI_RESULT_SUCCESS if the session is valid."]
    #[doc = "                 Otherwise, the session is invalid and passing it to"]
    #[doc = "                 other HAPI calls may result in undefined behavior."]
    #[doc = ""]
    pub fn HAPI_IsSessionValid(session: *const HAPI_Session) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Closes a session. If the session has been established using"]
    #[doc = "         RPC, then the RPC connection is closed."]
    #[doc = ""]
    #[doc = " @param[in]     session"]
    #[doc = "                The HAPI_Session to close. After this call, this"]
    #[doc = "                session is invalid and passing it to HAPI calls other"]
    #[doc = "                than ::HAPI_IsSessionValid() may result in undefined"]
    #[doc = "                behavior."]
    #[doc = ""]
    pub fn HAPI_CloseSession(session: *const HAPI_Session) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Check whether the runtime has been initialized yet using"]
    #[doc = "         ::HAPI_Initialize(). Function will return ::HAPI_RESULT_SUCCESS"]
    #[doc = "         if the runtime has been initialized and ::HAPI_RESULT_NOT_INITIALIZED"]
    #[doc = "         otherwise."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    pub fn HAPI_IsInitialized(session: *const HAPI_Session) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Create the asset manager, set up environment variables, and"]
    #[doc = "         initialize the main Houdini scene. No license checking is"]
    #[doc = "         during this step. Only when you try to load an asset library"]
    #[doc = "         (OTL) do we actually check for licenses."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      cook_options"]
    #[doc = "                 Global cook options used by subsequent default cooks."]
    #[doc = "                 This can be overwritten by individual cooks but if"]
    #[doc = "                 you choose to instantiate assets with cook_on_load"]
    #[doc = "                 set to true then these cook options will be used."]
    #[doc = ""]
    #[doc = " @param[in]      use_cooking_thread"]
    #[doc = "                 Use a separate thread for cooking of assets. This"]
    #[doc = "                 allows for asynchronous cooking and larger stack size."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[in]      cooking_thread_stack_size"]
    #[doc = "                 Set the stack size of the cooking thread. Use -1 to"]
    #[doc = "                 set the stack size to the Houdini default. This"]
    #[doc = "                 value is in bytes."]
    #[doc = "                 <!-- default -1 -->"]
    #[doc = ""]
    #[doc = " @param[in]      houdini_environment_files"]
    #[doc = "                 A list of paths, separated by a \";\" on Windows and a \":\""]
    #[doc = "                 on Linux and Mac, to .env files that follow the same"]
    #[doc = "                 syntax as the houdini.env file in Houdini's user prefs"]
    #[doc = "                 folder. These will be applied after the default"]
    #[doc = "                 houdini.env file and will overwrite the process'"]
    #[doc = "                 environment variable values. You an use this to enforce"]
    #[doc = "                 a stricter environment when running engine."]
    #[doc = "                 For more info, see:"]
    #[doc = "                 http://www.sidefx.com/docs/houdini/basics/config_env"]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      otl_search_path"]
    #[doc = "                 The directory where OTLs are searched for. You can"]
    #[doc = "                 pass NULL here which will only use the default"]
    #[doc = "                 Houdini OTL search paths. You can also pass in"]
    #[doc = "                 multiple paths separated by a \";\" on Windows and a \":\""]
    #[doc = "                 on Linux and Mac. If something other than NULL is"]
    #[doc = "                 passed the default Houdini search paths will be"]
    #[doc = "                 appended to the end of the path string."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      dso_search_path"]
    #[doc = "                 The directory where generic DSOs (custom plugins) are"]
    #[doc = "                 searched for. You can pass NULL here which will"]
    #[doc = "                 only use the default Houdini DSO search paths. You"]
    #[doc = "                 can also pass in multiple paths separated by a \";\""]
    #[doc = "                 on Windows and a \":\" on Linux and Mac. If something"]
    #[doc = "                 other than NULL is passed the default Houdini search"]
    #[doc = "                 paths will be appended to the end of the path string."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      image_dso_search_path"]
    #[doc = "                 The directory where image DSOs (custom plugins) are"]
    #[doc = "                 searched for. You can pass NULL here which will"]
    #[doc = "                 only use the default Houdini DSO search paths. You"]
    #[doc = "                 can also pass in multiple paths separated by a \";\""]
    #[doc = "                 on Windows and a \":\" on Linux and Mac. If something"]
    #[doc = "                 other than NULL is passed the default Houdini search"]
    #[doc = "                 paths will be appended to the end of the path string."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      audio_dso_search_path"]
    #[doc = "                 The directory where audio DSOs (custom plugins) are"]
    #[doc = "                 searched for. You can pass NULL here which will"]
    #[doc = "                 only use the default Houdini DSO search paths. You"]
    #[doc = "                 can also pass in multiple paths separated by a \";\""]
    #[doc = "                 on Windows and a \":\" on Linux and Mac. If something"]
    #[doc = "                 other than NULL is passed the default Houdini search"]
    #[doc = "                 paths will be appended to the end of the path string."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " [HAPI_Initialize]"]
    pub fn HAPI_Initialize(
        session: *const HAPI_Session,
        cook_options: *const HAPI_CookOptions,
        use_cooking_thread: HAPI_Bool,
        cooking_thread_stack_size: ::std::os::raw::c_int,
        houdini_environment_files: *const ::std::os::raw::c_char,
        otl_search_path: *const ::std::os::raw::c_char,
        dso_search_path: *const ::std::os::raw::c_char,
        image_dso_search_path: *const ::std::os::raw::c_char,
        audio_dso_search_path: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Clean up memory. This will unload all assets and you will"]
    #[doc = "         need to call ::HAPI_Initialize() again to be able to use any"]
    #[doc = "         HAPI methods again."]
    #[doc = ""]
    #[doc = "         @note This does NOT release any licenses."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    pub fn HAPI_Cleanup(session: *const HAPI_Session) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back a certain environment integers like version number."]
    #[doc = "         Note that you do not need a session for this. These constants"]
    #[doc = "         are hard-coded in all HAPI implementations, including HARC and"]
    #[doc = "         HAPIL. This should be the first API you call to determine if"]
    #[doc = "         any future API calls will mismatch implementation."]
    #[doc = ""]
    #[doc = " @param[in]      int_type"]
    #[doc = "                 One of ::HAPI_EnvIntType."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 Int value."]
    #[doc = ""]
    pub fn HAPI_GetEnvInt(
        int_type: HAPI_EnvIntType,
        value: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back a certain session-specific environment integers"]
    #[doc = "         like current license type being used."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      int_type"]
    #[doc = "                 One of ::HAPI_SessionEnvIntType."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 Int value."]
    #[doc = ""]
    pub fn HAPI_GetSessionEnvInt(
        session: *const HAPI_Session,
        int_type: HAPI_SessionEnvIntType,
        value: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get environment variable from the server process as an integer."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      variable_name"]
    #[doc = "                 Name of the environmnet variable."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The int pointer to return the value in."]
    #[doc = ""]
    pub fn HAPI_GetServerEnvInt(
        session: *const HAPI_Session,
        variable_name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get environment variable from the server process as a string."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      variable_name"]
    #[doc = "                 Name of the environmnet variable."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The HAPI_StringHandle pointer to return the value in."]
    #[doc = ""]
    pub fn HAPI_GetServerEnvString(
        session: *const HAPI_Session,
        variable_name: *const ::std::os::raw::c_char,
        value: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Provides the number of environment variables that are in"]
    #[doc = "         the server environment's process"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     env_count"]
    #[doc = "                 A pointer to an int to return the value in"]
    pub fn HAPI_GetServerEnvVarCount(
        session: *const HAPI_Session,
        env_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Provides a list of all of the environment variables"]
    #[doc = "         in the server's process"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 An ::HAPI_StringHandle array at least the size of length"]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least @c 0 and at most"]
    #[doc = "                 @c env_count returned by ::HAPI_GetServerEnvVarCount()"]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetServerEnvVarCount -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Given @c env_count returned by ::HAPI_GetServerEnvVarCount(),"]
    #[doc = "                 length should be at least @c 0 and at most <tt>env_count - start.</tt>"]
    #[doc = "                 <!-- default 0 -->"]
    pub fn HAPI_GetServerEnvVarList(
        session: *const HAPI_Session,
        values_array: *mut HAPI_StringHandle,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set environment variable for the server process as an integer."]
    #[doc = ""]
    #[doc = "         Note that this may affect other sessions on the same server"]
    #[doc = "         process. The session parameter is mainly there to identify the"]
    #[doc = "         server process, not the specific session."]
    #[doc = ""]
    #[doc = "         For in-process sessions, this will affect the current process's"]
    #[doc = "         environment."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      variable_name"]
    #[doc = "                 Name of the environment variable."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The integer value."]
    #[doc = ""]
    pub fn HAPI_SetServerEnvInt(
        session: *const HAPI_Session,
        variable_name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set environment variable for the server process as a string."]
    #[doc = ""]
    #[doc = "         Note that this may affect other sessions on the same server"]
    #[doc = "         process. The session parameter is mainly there to identify the"]
    #[doc = "         server process, not the specific session."]
    #[doc = ""]
    #[doc = "         For in-process sessions, this will affect the current process's"]
    #[doc = "         environment."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      variable_name"]
    #[doc = "                 Name of the environmnet variable."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The string value."]
    #[doc = ""]
    pub fn HAPI_SetServerEnvString(
        session: *const HAPI_Session,
        variable_name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back the status code for a specific status type."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      status_type"]
    #[doc = "                 One of ::HAPI_StatusType."]
    #[doc = ""]
    #[doc = " @param[out]     status"]
    #[doc = "                 Actual status code for the status type given. That is,"]
    #[doc = "                 if you pass in ::HAPI_STATUS_CALL_RESULT as"]
    #[doc = "                 status_type, you'll get back a ::HAPI_Result for this"]
    #[doc = "                 argument. If you pass in ::HAPI_STATUS_COOK_STATE"]
    #[doc = "                 as status_type, you'll get back a ::HAPI_State enum"]
    #[doc = "                 for this argument."]
    #[doc = ""]
    pub fn HAPI_GetStatus(
        session: *const HAPI_Session,
        status_type: HAPI_StatusType,
        status: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Return length of string buffer storing status string message."]
    #[doc = ""]
    #[doc = "         If called with ::HAPI_STATUS_COOK_RESULT this will actually"]
    #[doc = "         parse the node networks for the previously cooked asset(s)"]
    #[doc = "         and aggregate all node errors, warnings, and messages"]
    #[doc = "         (depending on the @c verbosity level set). Usually this is done"]
    #[doc = "         just for the last cooked single asset but if you load a whole"]
    #[doc = "         Houdini scene using ::HAPI_LoadHIPFile() then you'll have"]
    #[doc = "         multiple \"previously cooked assets\"."]
    #[doc = ""]
    #[doc = "         You MUST call ::HAPI_GetStatusStringBufLength() before calling"]
    #[doc = "         ::HAPI_GetStatusString() because ::HAPI_GetStatusString() will"]
    #[doc = "         not return the real status string and instead return a"]
    #[doc = "         cached version of the string that was created inside"]
    #[doc = "         ::HAPI_GetStatusStringBufLength(). The reason for this is that"]
    #[doc = "         the length of the real status string may change between"]
    #[doc = "         the call to ::HAPI_GetStatusStringBufLength() and the call to"]
    #[doc = "         ::HAPI_GetStatusString()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      status_type"]
    #[doc = "                 One of ::HAPI_StatusType."]
    #[doc = ""]
    #[doc = " @param[in]      verbosity"]
    #[doc = "                 Preferred verbosity level."]
    #[doc = ""]
    #[doc = " @param[out]     buffer_length"]
    #[doc = "                 Length of buffer char array ready to be filled."]
    #[doc = ""]
    pub fn HAPI_GetStatusStringBufLength(
        session: *const HAPI_Session,
        status_type: HAPI_StatusType,
        verbosity: HAPI_StatusVerbosity,
        buffer_length: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Return status string message."]
    #[doc = ""]
    #[doc = "         You MUST call ::HAPI_GetStatusStringBufLength() before calling"]
    #[doc = "         ::HAPI_GetStatusString() because ::HAPI_GetStatusString() will"]
    #[doc = "         not return the real status string and instead return a"]
    #[doc = "         cached version of the string that was created inside"]
    #[doc = "         ::HAPI_GetStatusStringBufLength(). The reason for this is that"]
    #[doc = "         the length of the real status string may change between"]
    #[doc = "         the call to ::HAPI_GetStatusStringBufLength() and the call to"]
    #[doc = "         ::HAPI_GetStatusString()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      status_type"]
    #[doc = "                 One of ::HAPI_StatusType."]
    #[doc = ""]
    #[doc = " @param[out]     string_value"]
    #[doc = "                 Buffer char array ready to be filled."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Length of the string buffer (must match size of"]
    #[doc = "                 @p string_value - so including NULL terminator)."]
    #[doc = "                 <!-- source ::HAPI_GetStatusStringBufLength -->"]
    #[doc = ""]
    pub fn HAPI_GetStatusString(
        session: *const HAPI_Session,
        status_type: HAPI_StatusType,
        string_value: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Compose the cook result string (errors and warnings) of a"]
    #[doc = "         specific node."]
    #[doc = ""]
    #[doc = "         This will actually parse the node network inside the given"]
    #[doc = "         node and return ALL errors/warnings/messages of all child nodes,"]
    #[doc = "         combined into a single string. If you'd like a more narrowed"]
    #[doc = "         search, call this function on one of the child nodes."]
    #[doc = ""]
    #[doc = "         You MUST call ::HAPI_ComposeNodeCookResult() before calling"]
    #[doc = "         ::HAPI_GetComposedNodeCookResult() because"]
    #[doc = "         ::HAPI_GetComposedNodeCookResult() will"]
    #[doc = "         not return the real result string and instead return a"]
    #[doc = "         cached version of the string that was created inside"]
    #[doc = "         ::HAPI_ComposeNodeCookResult(). The reason for this is that"]
    #[doc = "         the length of the real status string may change between"]
    #[doc = "         the call to ::HAPI_ComposeNodeCookResult() and the call to"]
    #[doc = "         ::HAPI_GetComposedNodeCookResult()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      verbosity"]
    #[doc = "                 Preferred verbosity level."]
    #[doc = ""]
    #[doc = " @param[out]     buffer_length"]
    #[doc = "                 Length of buffer char array ready to be filled."]
    #[doc = ""]
    pub fn HAPI_ComposeNodeCookResult(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        verbosity: HAPI_StatusVerbosity,
        buffer_length: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Return cook result string message on a single node."]
    #[doc = ""]
    #[doc = "         You MUST call ::HAPI_ComposeNodeCookResult() before calling"]
    #[doc = "         ::HAPI_GetComposedNodeCookResult() because"]
    #[doc = "         ::HAPI_GetComposedNodeCookResult() will"]
    #[doc = "         not return the real result string and instead return a"]
    #[doc = "         cached version of the string that was created inside"]
    #[doc = "         ::HAPI_ComposeNodeCookResult(). The reason for this is that"]
    #[doc = "         the length of the real status string may change between"]
    #[doc = "         the call to ::HAPI_ComposeNodeCookResult() and the call to"]
    #[doc = "         ::HAPI_GetComposedNodeCookResult()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     string_value"]
    #[doc = "                 Buffer char array ready to be filled."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Length of the string buffer (must match size of"]
    #[doc = "                 @p string_value - so including NULL terminator)."]
    #[doc = "                 <!-- source ::HAPI_ComposeNodeCookResult -->"]
    #[doc = ""]
    pub fn HAPI_GetComposedNodeCookResult(
        session: *const HAPI_Session,
        string_value: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Recursively check for specific errors by error code on a node."]
    #[doc = ""]
    #[doc = "         Note that checking for errors can be expensive because it checks"]
    #[doc = "         ALL child nodes within a node and then tries to do a string match"]
    #[doc = "         for the errors being looked for. This is why such error checking"]
    #[doc = "         is part of a standalone function and not done during the cooking"]
    #[doc = "         step."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      errors_to_look_for"]
    #[doc = "                 The HAPI_ErrorCode error codes (as a bitfield) to look for."]
    #[doc = ""]
    #[doc = " @param[out]     errors_found"]
    #[doc = "                 Returned HAPI_ErrorCode bitfield indicating which of the"]
    #[doc = "                 looked for errors have been found."]
    #[doc = ""]
    pub fn HAPI_CheckForSpecificErrors(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        errors_to_look_for: HAPI_ErrorCodeBits,
        errors_found: *mut HAPI_ErrorCodeBits,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Clears the connection error. Should be used before starting"]
    #[doc = "         or creating Thrift server."]
    #[doc = ""]
    #[doc = "         Only available when using Thrift connections."]
    #[doc = ""]
    pub fn HAPI_ClearConnectionError() -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Return the length of string buffer storing connection error"]
    #[doc = "         message."]
    #[doc = ""]
    #[doc = "         Only available when using Thrift connections."]
    #[doc = ""]
    #[doc = " @param[out]     buffer_length"]
    #[doc = "                 Length of buffer char array ready to be filled."]
    #[doc = ""]
    pub fn HAPI_GetConnectionErrorLength(buffer_length: *mut ::std::os::raw::c_int) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Return the connection error message."]
    #[doc = ""]
    #[doc = "         You MUST call ::HAPI_GetConnectionErrorLength() before calling"]
    #[doc = "         this to get the correct string length."]
    #[doc = ""]
    #[doc = "         Only available when using Thrift connections."]
    #[doc = ""]
    #[doc = " @param[out]     string_value"]
    #[doc = "                 Buffer char array ready to be filled."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Length of the string buffer (must match size of"]
    #[doc = "                 string_value - so including NULL terminator)."]
    #[doc = "                 Use ::HAPI_GetConnectionErrorLength to get this length."]
    #[doc = ""]
    #[doc = " @param[in]      clear"]
    #[doc = "                 If true, will clear the error when HAPI_RESULT_SUCCESS"]
    #[doc = "                 is returned."]
    #[doc = ""]
    pub fn HAPI_GetConnectionError(
        string_value: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        clear: HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get total number of nodes that need to cook in the current"]
    #[doc = "         session."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     count"]
    #[doc = "                 Total cook count."]
    #[doc = ""]
    pub fn HAPI_GetCookingTotalCount(
        session: *const HAPI_Session,
        count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get current number of nodes that have already cooked in the"]
    #[doc = "         current session. Note that this is a very crude approximation"]
    #[doc = "         of the cooking progress - it may never make it to 100% or it"]
    #[doc = "         might spend another hour at 100%. Use ::HAPI_GetStatusString"]
    #[doc = "         to get a better idea of progress if this number gets stuck."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     count"]
    #[doc = "                 Current cook count."]
    #[doc = ""]
    pub fn HAPI_GetCookingCurrentCount(
        session: *const HAPI_Session,
        count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Converts the transform described by a ::HAPI_TransformEuler"]
    #[doc = "         struct into a different transform and rotation order."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      transform_in"]
    #[doc = "                 The transform to be converted."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The desired transform order of the output."]
    #[doc = ""]
    #[doc = " @param[in]      rot_order"]
    #[doc = "                 The desired rotation order of the output."]
    #[doc = ""]
    #[doc = " @param[out]     transform_out"]
    #[doc = "                 The converted transform."]
    #[doc = ""]
    pub fn HAPI_ConvertTransform(
        session: *const HAPI_Session,
        transform_in: *const HAPI_TransformEuler,
        rst_order: HAPI_RSTOrder,
        rot_order: HAPI_XYZOrder,
        transform_out: *mut HAPI_TransformEuler,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Converts a 4x4 matrix into its TRS form."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      matrix"]
    #[doc = "                 A 4x4 matrix expressed in a 16 element float array."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The desired transform order of the output."]
    #[doc = ""]
    #[doc = " @param[out]     transform_out"]
    #[doc = "                 Used for the output."]
    #[doc = ""]
    pub fn HAPI_ConvertMatrixToQuat(
        session: *const HAPI_Session,
        matrix: *const f32,
        rst_order: HAPI_RSTOrder,
        transform_out: *mut HAPI_Transform,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Converts a 4x4 matrix into its TRS form."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      matrix"]
    #[doc = "                 A 4x4 matrix expressed in a 16 element float array."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The desired transform order of the output."]
    #[doc = ""]
    #[doc = " @param[in]      rot_order"]
    #[doc = "                 The desired rotation order of the output."]
    #[doc = ""]
    #[doc = " @param[out]     transform_out"]
    #[doc = "                 Used for the output."]
    #[doc = ""]
    pub fn HAPI_ConvertMatrixToEuler(
        session: *const HAPI_Session,
        matrix: *const f32,
        rst_order: HAPI_RSTOrder,
        rot_order: HAPI_XYZOrder,
        transform_out: *mut HAPI_TransformEuler,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Converts ::HAPI_Transform into a 4x4 transform matrix."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      transform"]
    #[doc = "                 The ::HAPI_Transform you wish to convert."]
    #[doc = ""]
    #[doc = " @param[out]     matrix"]
    #[doc = "                 A 16 element float array that will contain the result."]
    #[doc = ""]
    pub fn HAPI_ConvertTransformQuatToMatrix(
        session: *const HAPI_Session,
        transform: *const HAPI_Transform,
        matrix: *mut f32,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Converts ::HAPI_TransformEuler into a 4x4 transform matrix."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      transform"]
    #[doc = "                 The ::HAPI_TransformEuler you wish to convert."]
    #[doc = ""]
    #[doc = " @param[out]     matrix"]
    #[doc = "                 A 16 element float array that will contain the result."]
    #[doc = ""]
    pub fn HAPI_ConvertTransformEulerToMatrix(
        session: *const HAPI_Session,
        transform: *const HAPI_TransformEuler,
        matrix: *mut f32,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Acquires or releases the Python interpreter lock. This is"]
    #[doc = "         needed if HAPI is called from Python and HAPI is in threaded"]
    #[doc = "         mode (see ::HAPI_Initialize())."]
    #[doc = ""]
    #[doc = "         The problem arises when async functions like"]
    #[doc = "         ::HAPI_CreateNode() may start a cooking thread that"]
    #[doc = "         may try to run Python code. That is, we would now have"]
    #[doc = "         Python running on two different threads - something not"]
    #[doc = "         allowed by Python by default."]
    #[doc = ""]
    #[doc = "         We need to tell Python to explicitly \"pause\" the Python state"]
    #[doc = "         on the client thread while we run Python in our cooking thread."]
    #[doc = ""]
    #[doc = "         You must call this function first with locked == true before"]
    #[doc = "         any async HAPI call. Then, after the async call finished,"]
    #[doc = "         detected via calls to ::HAPI_GetStatus(), call this method"]
    #[doc = "         again to release the lock with locked == false."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      locked"]
    #[doc = "                 True will acquire the interpreter lock to use it for"]
    #[doc = "                 the HAPI cooking thread. False will release the lock"]
    #[doc = "                 back to the client thread."]
    #[doc = ""]
    pub fn HAPI_PythonThreadInterpreterLock(
        session: *const HAPI_Session,
        locked: HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back the string length of the string with the"]
    #[doc = "         given handle."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      string_handle"]
    #[doc = "                 Handle of the string to query."]
    #[doc = ""]
    #[doc = " @param[out]     buffer_length"]
    #[doc = "                 Buffer length of the queried string (including NULL"]
    #[doc = "                 terminator)."]
    #[doc = ""]
    pub fn HAPI_GetStringBufLength(
        session: *const HAPI_Session,
        string_handle: HAPI_StringHandle,
        buffer_length: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back the string value of the string with the"]
    #[doc = "         given handle."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      string_handle"]
    #[doc = "                 Handle of the string to query."]
    #[doc = ""]
    #[doc = " @param[out]     string_value"]
    #[doc = "                 Actual string value (character array)."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Length of the string buffer (must match size of"]
    #[doc = "                 @p string_value - so including NULL terminator)."]
    #[doc = ""]
    pub fn HAPI_GetString(
        session: *const HAPI_Session,
        string_handle: HAPI_StringHandle,
        string_value: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Adds the given string to the string table and returns"]
    #[doc = "         the handle. It is the responsibility of the caller to"]
    #[doc = "         manage access to the string. The intended use for custom strings"]
    #[doc = "         is to allow structs that reference strings to be passed in to HAPI"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      string_value"]
    #[doc = "                 Actual string value (character array)."]
    #[doc = ""]
    #[doc = " @param[out]     handle_value"]
    #[doc = "                 Handle of the string that was added"]
    #[doc = ""]
    pub fn HAPI_SetCustomString(
        session: *const HAPI_Session,
        string_value: *const ::std::os::raw::c_char,
        handle_value: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Removes the specified string from the server"]
    #[doc = "         and invalidates the handle"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]     string_handle"]
    #[doc = "                 Handle of the string that was added"]
    #[doc = ""]
    pub fn HAPI_RemoveCustomString(
        session: *const HAPI_Session,
        string_handle: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back the length of the buffer needed to hold"]
    #[doc = "         all the values null-separated for the given string"]
    #[doc = "         handles.  Used with HAPI_GetStringBatch."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      string_handle_array"]
    #[doc = "                 Array of string handles to be read."]
    #[doc = ""]
    #[doc = " @param[in]      string_handle_count"]
    #[doc = "                 Length of @p string_handle_array"]
    #[doc = ""]
    #[doc = " @param[out]     string_buffer_size"]
    #[doc = "                 Buffer length required for subsequent call to"]
    #[doc = "                 HAPI_GetStringBatch to hold all the given"]
    #[doc = "                 string values null-terminated"]
    #[doc = ""]
    pub fn HAPI_GetStringBatchSize(
        session: *const HAPI_Session,
        string_handle_array: *const ::std::os::raw::c_int,
        string_handle_count: ::std::os::raw::c_int,
        string_buffer_size: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gives back the values of the given string handles."]
    #[doc = "         The given char array is filled with null-separated"]
    #[doc = "         values, and the final value is null-terminated."]
    #[doc = "         Used with HAPI_GetStringBatchSize.  Using this function"]
    #[doc = "         instead of repeated calls to HAPI_GetString can be more"]
    #[doc = "         more efficient for a large number of strings."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     char_buffer"]
    #[doc = "                 Array of characters to hold string values."]
    #[doc = ""]
    #[doc = " @param[in]      char_array_length"]
    #[doc = "                 Length of @p char_array.  Must be large enough to hold"]
    #[doc = "                 all the string values including null separators."]
    #[doc = "                 <!-- min ::HAPI_GetStringBatchSize -->"]
    #[doc = "                 <!-- source ::HAPI_GetStringBatchSize -->"]
    #[doc = ""]
    pub fn HAPI_GetStringBatch(
        session: *const HAPI_Session,
        char_buffer: *mut ::std::os::raw::c_char,
        char_array_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gets the global time of the scene. All API calls deal with"]
    #[doc = "         this time to cook."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     time"]
    #[doc = "                 Time as a float in seconds."]
    #[doc = ""]
    pub fn HAPI_GetTime(session: *const HAPI_Session, time: *mut f32) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Sets the global time of the scene. All API calls will deal"]
    #[doc = "         with this time to cook."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      time"]
    #[doc = "                 Time as a float in seconds."]
    #[doc = ""]
    pub fn HAPI_SetTime(session: *const HAPI_Session, time: f32) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Returns whether the Houdini session will use the current time in"]
    #[doc = "         Houdini when cooking and retrieving data. By default this is"]
    #[doc = "         disabled and the Houdini session uses time 0 (i.e. frame 1)."]
    #[doc = "         In SessionSync, it is enabled by default, but can be overridden."]
    #[doc = "         Note that this function will ALWAYS return"]
    #[doc = "         ::HAPI_RESULT_SUCCESS."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     enabled"]
    #[doc = "                 Whether use Houdini time is enabled or not."]
    #[doc = ""]
    pub fn HAPI_GetUseHoudiniTime(
        session: *const HAPI_Session,
        enabled: *mut HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Sets whether the Houdini session should use the current time in"]
    #[doc = "         Houdini when cooking and retrieving data. By default this is"]
    #[doc = "         disabled and the Houdini session uses time 0 (i.e. frame 1)."]
    #[doc = "         In SessionSync, it is enabled by default, but can be overridden."]
    #[doc = "         Note that this function will ALWAYS return"]
    #[doc = "         ::HAPI_RESULT_SUCCESS."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      enabled"]
    #[doc = "                 Set to true to use Houdini time."]
    #[doc = ""]
    pub fn HAPI_SetUseHoudiniTime(session: *const HAPI_Session, enabled: HAPI_Bool) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gets the current global timeline options."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     timeline_options"]
    #[doc = "                 The global timeline options struct."]
    #[doc = ""]
    pub fn HAPI_GetTimelineOptions(
        session: *const HAPI_Session,
        timeline_options: *mut HAPI_TimelineOptions,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Sets the global timeline options."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      timeline_options"]
    #[doc = "                 The global timeline options struct."]
    #[doc = ""]
    pub fn HAPI_SetTimelineOptions(
        session: *const HAPI_Session,
        timeline_options: *const HAPI_TimelineOptions,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads a Houdini asset library (OTL) from a .otl file."]
    #[doc = "         It does NOT create anything inside the Houdini scene."]
    #[doc = ""]
    #[doc = "         @note This is when we actually check for valid licenses."]
    #[doc = ""]
    #[doc = "         The next step is to call ::HAPI_GetAvailableAssetCount()"]
    #[doc = "         to get the number of assets contained in the library using the"]
    #[doc = "         returned library_id. Then call ::HAPI_GetAvailableAssets()"]
    #[doc = "         to get the list of available assets by name. Use the asset"]
    #[doc = "         names with ::HAPI_CreateNode() to actually create"]
    #[doc = "         one of these nodes in the Houdini scene and get back"]
    #[doc = "         an asset_id."]
    #[doc = ""]
    #[doc = "         @note The HIP file saved using ::HAPI_SaveHIPFile() will only"]
    #[doc = "             have an absolute path reference to the loaded OTL meaning"]
    #[doc = "             that if the OTL is moved or renamed the HIP file won't"]
    #[doc = "             load properly. It also means that if you change the OTL"]
    #[doc = "             using the saved HIP scene the same OTL file will change"]
    #[doc = "             as the one used with Houdini Engine."]
    #[doc = "             See @ref HAPI_Fundamentals_SavingHIPFile."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      file_path"]
    #[doc = "                 Absolute path to the .otl file."]
    #[doc = ""]
    #[doc = " @param[in]      allow_overwrite"]
    #[doc = "                 With this true, if the library file being loaded"]
    #[doc = "                 contains asset definitions that have already been"]
    #[doc = "                 loaded they will overwrite the existing definitions."]
    #[doc = "                 Otherwise, a library containing asset definitions that"]
    #[doc = "                 already exist will fail to load, returning a"]
    #[doc = "                 ::HAPI_Result of"]
    #[doc = "                 ::HAPI_RESULT_ASSET_DEF_ALREADY_LOADED."]
    #[doc = ""]
    #[doc = " @param[out]     library_id"]
    #[doc = "                 Newly loaded otl id to be used with"]
    #[doc = "                 ::HAPI_GetAvailableAssetCount() and"]
    #[doc = "                 ::HAPI_GetAvailableAssets()."]
    #[doc = ""]
    pub fn HAPI_LoadAssetLibraryFromFile(
        session: *const HAPI_Session,
        file_path: *const ::std::os::raw::c_char,
        allow_overwrite: HAPI_Bool,
        library_id: *mut HAPI_AssetLibraryId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads a Houdini asset library (OTL) from memory."]
    #[doc = "         It does NOT create anything inside the Houdini scene."]
    #[doc = ""]
    #[doc = "         @note This is when we actually check for valid licenses."]
    #[doc = ""]
    #[doc = "         Please note that the performance benefit of loading a library"]
    #[doc = "         from memory are negligible at best. Due to limitations of"]
    #[doc = "         Houdini's library manager, there is still some disk access"]
    #[doc = "         and file writes because every asset library needs to be"]
    #[doc = "         saved to a real file. Use this function only as a convenience"]
    #[doc = "         if you already have the library file in memory and don't wish"]
    #[doc = "         to have to create your own temporary library file and then"]
    #[doc = "         call ::HAPI_LoadAssetLibraryFromFile()."]
    #[doc = ""]
    #[doc = "         The next step is to call ::HAPI_GetAvailableAssetCount()"]
    #[doc = "         to get the number of assets contained in the library using the"]
    #[doc = "         returned library_id. Then call ::HAPI_GetAvailableAssets()"]
    #[doc = "         to get the list of available assets by name. Use the asset"]
    #[doc = "         names with ::HAPI_CreateNode() to actually create"]
    #[doc = "         one of these nodes in the Houdini scene and get back"]
    #[doc = "         an asset_id."]
    #[doc = ""]
    #[doc = "         @note The saved HIP file using ::HAPI_SaveHIPFile() will"]
    #[doc = "             @a contain the OTL loaded as part of its @b Embedded OTLs."]
    #[doc = "             This means that you can safely move or rename the original"]
    #[doc = "             OTL file and the HIP will continue to work but if you make"]
    #[doc = "             changes to the OTL while using the saved HIP the changes"]
    #[doc = "             won't be saved to the original OTL."]
    #[doc = "             See @ref HAPI_Fundamentals_SavingHIPFile."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      library_buffer"]
    #[doc = "                 The memory buffer containing the asset definitions"]
    #[doc = "                 in the same format as a standard Houdini .otl file."]
    #[doc = ""]
    #[doc = " @param[in]      library_buffer_length"]
    #[doc = "                 The size of the OTL memory buffer."]
    #[doc = ""]
    #[doc = " @param[in]      allow_overwrite"]
    #[doc = "                 With this true, if the library file being loaded"]
    #[doc = "                 contains asset definitions that have already been"]
    #[doc = "                 loaded they will overwrite the existing definitions."]
    #[doc = "                 Otherwise, a library containing asset definitions that"]
    #[doc = "                 already exist will fail to load, returning a"]
    #[doc = "                 ::HAPI_Result of"]
    #[doc = "                 ::HAPI_RESULT_ASSET_DEF_ALREADY_LOADED."]
    #[doc = ""]
    #[doc = " @param[out]     library_id"]
    #[doc = "                 Newly loaded otl id to be used with"]
    #[doc = "                 ::HAPI_GetAvailableAssetCount() and"]
    #[doc = "                 ::HAPI_GetAvailableAssets()."]
    #[doc = ""]
    pub fn HAPI_LoadAssetLibraryFromMemory(
        session: *const HAPI_Session,
        library_buffer: *const ::std::os::raw::c_char,
        library_buffer_length: ::std::os::raw::c_int,
        allow_overwrite: HAPI_Bool,
        library_id: *mut HAPI_AssetLibraryId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the number of assets contained in an asset library."]
    #[doc = "         You should call ::HAPI_LoadAssetLibraryFromFile() prior to"]
    #[doc = "         get a library_id."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      library_id"]
    #[doc = "                 Returned by ::HAPI_LoadAssetLibraryFromFile()."]
    #[doc = "                 <!-- source ::HAPI_LoadAssetLibraryFromFile -->"]
    #[doc = ""]
    #[doc = " @param[out]     asset_count"]
    #[doc = "                 The number of assets contained in this asset library."]
    #[doc = ""]
    pub fn HAPI_GetAvailableAssetCount(
        session: *const HAPI_Session,
        library_id: HAPI_AssetLibraryId,
        asset_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the names of the assets contained in an asset library."]
    #[doc = ""]
    #[doc = "         The asset names will contain additional information about"]
    #[doc = "         the type of asset, namespace, and version, along with the"]
    #[doc = "         actual asset name. For example, if you have an Object type"]
    #[doc = "         asset, in the \"hapi\" namespace, of version 2.0, named"]
    #[doc = "         \"foo\", the asset name returned here will be:"]
    #[doc = "         hapi::Object/foo::2.0"]
    #[doc = ""]
    #[doc = "         However, you should not need to worry about this detail. Just"]
    #[doc = "         pass this string directly to ::HAPI_CreateNode() to"]
    #[doc = "         create the node. You can then get the pretty name"]
    #[doc = "         using ::HAPI_GetAssetInfo()."]
    #[doc = ""]
    #[doc = "         You should call ::HAPI_LoadAssetLibraryFromFile() prior to"]
    #[doc = "         get a library_id. Then, you should call"]
    #[doc = "         ::HAPI_GetAvailableAssetCount() to get the number of assets to"]
    #[doc = "         know how large of a string handles array you need to allocate."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      library_id"]
    #[doc = "                 Returned by ::HAPI_LoadAssetLibraryFromFile()."]
    #[doc = "                 <!-- source ::HAPI_LoadAssetLibraryFromFile -->"]
    #[doc = ""]
    #[doc = " @param[out]     asset_names_array"]
    #[doc = "                 Array of string handles (integers) that should be"]
    #[doc = "                 at least the size of asset_count."]
    #[doc = ""]
    #[doc = " @param[in]     asset_count"]
    #[doc = "                 Should be the same or less than the value returned by"]
    #[doc = "                 ::HAPI_GetAvailableAssetCount()."]
    #[doc = "                 <!-- max ::HAPI_GetAvailableAssetCount -->"]
    #[doc = "                 <!-- source ::HAPI_GetAvailableAssetCount -->"]
    #[doc = ""]
    pub fn HAPI_GetAvailableAssets(
        session: *const HAPI_Session,
        library_id: HAPI_AssetLibraryId,
        asset_names_array: *mut HAPI_StringHandle,
        asset_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an asset_info struct from a node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     asset_info"]
    #[doc = "                 Returned ::HAPI_AssetInfo struct."]
    #[doc = ""]
    pub fn HAPI_GetAssetInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        asset_info: *mut HAPI_AssetInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the number of asset parameters contained in an asset"]
    #[doc = "         library, as well as the number of parameter int, float,"]
    #[doc = "         string, and choice values."]
    #[doc = ""]
    #[doc = "         This does not create the asset in the session."]
    #[doc = "         Use this for faster querying of asset parameters compared to"]
    #[doc = "         creating the asset node and querying the node's parameters."]
    #[doc = ""]
    #[doc = "         This does require ::HAPI_LoadAssetLibraryFromFile() to be"]
    #[doc = "         called prior, in order to load the asset library and"]
    #[doc = "         acquire library_id. Then ::HAPI_GetAvailableAssetCount and"]
    #[doc = "         ::HAPI_GetAvailableAssets should be called to get the"]
    #[doc = "         asset_name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      library_id"]
    #[doc = "                 Returned by ::HAPI_LoadAssetLibraryFromFile()."]
    #[doc = "                 <!-- source ::HAPI_LoadAssetLibraryFromFile -->"]
    #[doc = ""]
    #[doc = " @param[in]      asset_name"]
    #[doc = "                 Name of the asset to get the parm counts for."]
    #[doc = ""]
    #[doc = " @param[out]     parm_count"]
    #[doc = "                 The number of parameters in the asset library."]
    #[doc = ""]
    #[doc = " @param[out]     int_value_count"]
    #[doc = "                 The number of int values for parameters in the asset"]
    #[doc = "                 library."]
    #[doc = ""]
    #[doc = " @param[out]     float_value_count"]
    #[doc = "                 The number of float values for parameters in the asset"]
    #[doc = "                 library."]
    #[doc = ""]
    #[doc = " @param[out]     string_value_count"]
    #[doc = "                 The number of string values for parameters in the asset"]
    #[doc = "                 library."]
    #[doc = ""]
    #[doc = " @param[out]     choice_value_count"]
    #[doc = "                 The number of choice values for parameters in the asset"]
    #[doc = "                 library."]
    #[doc = ""]
    pub fn HAPI_GetAssetDefinitionParmCounts(
        session: *const HAPI_Session,
        library_id: HAPI_AssetLibraryId,
        asset_name: *const ::std::os::raw::c_char,
        parm_count: *mut ::std::os::raw::c_int,
        int_value_count: *mut ::std::os::raw::c_int,
        float_value_count: *mut ::std::os::raw::c_int,
        string_value_count: *mut ::std::os::raw::c_int,
        choice_value_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_ParmInfo structs with parameter"]
    #[doc = "         information for the specified asset in the specified asset"]
    #[doc = "         library."]
    #[doc = ""]
    #[doc = "         This does not create the asset in the session."]
    #[doc = "         Use this for faster querying of asset parameters compared to"]
    #[doc = "         creating the asset node and querying the node's parameters."]
    #[doc = ""]
    #[doc = "         This does require ::HAPI_LoadAssetLibraryFromFile() to be"]
    #[doc = "         called prior, in order to load the asset library and"]
    #[doc = "         acquire library_id. ::HAPI_GetAssetDefinitionParmCounts should"]
    #[doc = "         be called prior to acquire the count for the size of"]
    #[doc = "         parm_infos_array."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      library_id"]
    #[doc = "                 Returned by ::HAPI_LoadAssetLibraryFromFile()."]
    #[doc = "                 <!-- source ::HAPI_LoadAssetLibraryFromFile -->"]
    #[doc = ""]
    #[doc = " @param[in]      asset_name"]
    #[doc = "                 Name of the asset to get the parm counts for."]
    #[doc = ""]
    #[doc = " @param[out]     parm_infos_array"]
    #[doc = "                 Array of ::HAPI_ParmInfo at least the size of"]
    #[doc = "                 length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most parm_count - 1 acquired from"]
    #[doc = "                 ::HAPI_GetAssetInfo."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetInfo::parm_count - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most parm_count - start acquired"]
    #[doc = "                 from ::HAPI_GetAssetInfo"]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetInfo::parm_count - start -->"]
    #[doc = "                 <!-- source ::HAPI_GetAssetInfo::parm_count -->"]
    #[doc = ""]
    pub fn HAPI_GetAssetDefinitionParmInfos(
        session: *const HAPI_Session,
        library_id: HAPI_AssetLibraryId,
        asset_name: *const ::std::os::raw::c_char,
        parm_infos_array: *mut HAPI_ParmInfo,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill arrays of parameter int values, float values, string values,"]
    #[doc = "         and choice values for parameters in the specified asset in the"]
    #[doc = "         specified asset library."]
    #[doc = ""]
    #[doc = "         This does not create the asset in the session."]
    #[doc = "         Use this for faster querying of asset parameters compared to"]
    #[doc = "         creating the asset node and querying the node's parameters."]
    #[doc = "         Note that only default values are retrieved."]
    #[doc = ""]
    #[doc = "         This does require ::HAPI_LoadAssetLibraryFromFile() to be"]
    #[doc = "         called prior, in order to load the asset library and"]
    #[doc = "         acquire library_id. ::HAPI_GetAssetDefinitionParmCounts should"]
    #[doc = "         be called prior to acquire the counts for the sizes of"]
    #[doc = "         the values arrays."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      library_id"]
    #[doc = "                 Returned by ::HAPI_LoadAssetLibraryFromFile()."]
    #[doc = "                 <!-- source ::HAPI_LoadAssetLibraryFromFile -->"]
    #[doc = ""]
    #[doc = " @param[in]      asset_name"]
    #[doc = "                 Name of the asset to get the parm counts for."]
    #[doc = ""]
    #[doc = " @param[out]     int_values_array"]
    #[doc = "                 Array of ints at least the size of int_length."]
    #[doc = ""]
    #[doc = " @param[in]      int_start"]
    #[doc = "                 First index of range for int_values_array. Must be at"]
    #[doc = "                 least 0 and at most int_value_count - 1 acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::int_value_count - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      int_length"]
    #[doc = "                 Must be at least 0 and at most int_value_count - int_start"]
    #[doc = "                 acquired from ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::int_value_count - int_start -->"]
    #[doc = "                 <!-- source ::HAPI_GetAssetDefinitionParmCounts::int_value_count - int_start -->"]
    #[doc = ""]
    #[doc = " @param[out]     float_values_array"]
    #[doc = "                 Array of floats at least the size of float_length."]
    #[doc = ""]
    #[doc = " @param[in]      float_start"]
    #[doc = "                 First index of range for float_values_array. Must be at"]
    #[doc = "                 least 0 and at most float_value_count - 1 acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::float_value_count - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      float_length"]
    #[doc = "                 Must be at least 0 and at most float_value_count -"]
    #[doc = "                 float_start acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::float_value_count - float_start -->"]
    #[doc = "                 <!-- source ::HAPI_GetAssetDefinitionParmCounts::float_value_count - float_start -->"]
    #[doc = ""]
    #[doc = " @param[in]      string_evaluate"]
    #[doc = "                 Whether or not to evaluate the string expressions."]
    #[doc = "                 For example, the string \"$F\" would evaluate to the"]
    #[doc = "                 current frame number. So, passing in evaluate = false"]
    #[doc = "                 would give you back the string \"$F\" and passing"]
    #[doc = "                 in evaluate = true would give you back \"1\" (assuming"]
    #[doc = "                 the current frame is 1)."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[out]     string_values_array"]
    #[doc = "                 Array of HAPI_StringHandle at least the size of"]
    #[doc = "                 string_length."]
    #[doc = ""]
    #[doc = " @param[in]      string_start"]
    #[doc = "                 First index of range for string_values_array. Must be at"]
    #[doc = "                 least 0 and at most string_value_count - 1 acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::string_value_count - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      string_length"]
    #[doc = "                 Must be at least 0 and at most string_value_count -"]
    #[doc = "                 string_start acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::string_value_count - string_start -->"]
    #[doc = "                 <!-- source ::HAPI_GetAssetDefinitionParmCounts::string_value_count - string_start -->"]
    #[doc = ""]
    #[doc = " @param[out]     choice_values_array"]
    #[doc = "                 Array of ::HAPI_ParmChoiceInfo at least the size of"]
    #[doc = "                 choice_length."]
    #[doc = ""]
    #[doc = " @param[in]      choice_start"]
    #[doc = "                 First index of range for choice_values_array. Must be at"]
    #[doc = "                 least 0 and at most choice_value_count - 1 acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::choice_value_count - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      choice_length"]
    #[doc = "                 Must be at least 0 and at most choice_value_count -"]
    #[doc = "                 choice_start acquired from"]
    #[doc = "                 ::HAPI_GetAssetDefinitionParmCounts."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_GetAssetDefinitionParmCounts::choice_value_count - choice_start -->"]
    #[doc = "                 <!-- source ::HAPI_GetAssetDefinitionParmCounts::choice_value_count - choice_start -->"]
    #[doc = ""]
    pub fn HAPI_GetAssetDefinitionParmValues(
        session: *const HAPI_Session,
        library_id: HAPI_AssetLibraryId,
        asset_name: *const ::std::os::raw::c_char,
        int_values_array: *mut ::std::os::raw::c_int,
        int_start: ::std::os::raw::c_int,
        int_length: ::std::os::raw::c_int,
        float_values_array: *mut f32,
        float_start: ::std::os::raw::c_int,
        float_length: ::std::os::raw::c_int,
        string_evaluate: HAPI_Bool,
        string_values_array: *mut HAPI_StringHandle,
        string_start: ::std::os::raw::c_int,
        string_length: ::std::os::raw::c_int,
        choice_values_array: *mut HAPI_ParmChoiceInfo,
        choice_start: ::std::os::raw::c_int,
        choice_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Interrupt a cook or load operation."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    pub fn HAPI_Interrupt(session: *const HAPI_Session) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads a .hip file into the main Houdini scene."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         @note This method will merge the HIP file into the scene. This means"]
    #[doc = "         that any registered `hou.hipFile` event callbacks will be triggered"]
    #[doc = "         with the `hou.hipFileEventType.BeforeMerge` and"]
    #[doc = "         `hou.hipFileEventType.AfterMerge` events."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      file_name"]
    #[doc = "                 Absolute path to the .hip file to load."]
    #[doc = ""]
    #[doc = " @param[in]      cook_on_load"]
    #[doc = "                 Set to true if you wish the nodes to cook as soon"]
    #[doc = "                 as they are created. Otherwise, you will have to"]
    #[doc = "                 call ::HAPI_CookNode() explicitly for each after you"]
    #[doc = "                 call this function."]
    #[doc = "                 <!-- default false -->"]
    #[doc = ""]
    pub fn HAPI_LoadHIPFile(
        session: *const HAPI_Session,
        file_name: *const ::std::os::raw::c_char,
        cook_on_load: HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads a .hip file into the main Houdini scene."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         @note This method will merge the HIP file into the scene. This means"]
    #[doc = "         that any registered `hou.hipFile` event callbacks will be triggered"]
    #[doc = "         with the `hou.hipFileEventType.BeforeMerge` and"]
    #[doc = "         `hou.hipFileEventType.AfterMerge` events."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[in]      file_name"]
    #[doc = "                 Absolute path to the .hip file to load."]
    #[doc = ""]
    #[doc = " @param[in]      cook_on_load"]
    #[doc = "                 Set to true if you wish the nodes to cook as soon"]
    #[doc = "                 as they are created. Otherwise, you will have to"]
    #[doc = "                 call ::HAPI_CookNode() explicitly for each after you"]
    #[doc = "                 call this function."]
    #[doc = ""]
    #[doc = " @param[out]     file_id"]
    #[doc = "                 This parameter will be set to the HAPI_HIPFileId of the"]
    #[doc = "                 loaded HIP file. This can be used to lookup nodes that were"]
    #[doc = "                 created as a result of loading this HIP file."]
    #[doc = ""]
    pub fn HAPI_MergeHIPFile(
        session: *const HAPI_Session,
        file_name: *const ::std::os::raw::c_char,
        cook_on_load: HAPI_Bool,
        file_id: *mut HAPI_HIPFileId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Saves a .hip file of the current Houdini scene."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      file_path"]
    #[doc = "                 Absolute path to the .hip file to save to."]
    #[doc = ""]
    #[doc = " @param[in]      lock_nodes"]
    #[doc = "                 Specify whether to lock all SOP nodes before saving"]
    #[doc = "                 the scene file. This way, when you load the scene"]
    #[doc = "                 file you can see exactly the state of each SOP at"]
    #[doc = "                 the time it was saved instead of relying on the"]
    #[doc = "                 re-cook to accurately reproduce the state. It does,"]
    #[doc = "                 however, take a lot more space and time locking all"]
    #[doc = "                 nodes like this."]
    #[doc = "                 <!-- default false -->"]
    #[doc = ""]
    pub fn HAPI_SaveHIPFile(
        session: *const HAPI_Session,
        file_path: *const ::std::os::raw::c_char,
        lock_nodes: HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gets the number of nodes that were created as a result of loading a"]
    #[doc = "         .hip file"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[in]      id"]
    #[doc = "                 The HIP file id."]
    #[doc = ""]
    #[doc = " @param[out]     count"]
    #[doc = "                 Pointer to an int where the HIP file node count will be"]
    #[doc = "                 stored."]
    pub fn HAPI_GetHIPFileNodeCount(
        session: *const HAPI_Session,
        id: HAPI_HIPFileId,
        count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fills an array of ::HAPI_NodeIds of nodes that were created as a"]
    #[doc = "         result of loading the HIP file specified by the ::HAPI_HIPFileId"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[in]      id"]
    #[doc = "                 The HIP file id."]
    #[doc = ""]
    #[doc = " @param[out]     node_ids"]
    #[doc = "                 Array of ::HAPI_NodeId at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of ::HAPI_NodeId to be stored. This should be at"]
    #[doc = "                 least 0 and at most the count provided by"]
    #[doc = "                 HAPI_GetHIPFileNodeCount"]
    pub fn HAPI_GetHIPFileNodeIds(
        session: *const HAPI_Session,
        id: HAPI_HIPFileId,
        node_ids: *mut HAPI_NodeId,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Determine if your instance of the node actually still exists"]
    #[doc = "         inside the Houdini scene. This is what can be used to"]
    #[doc = "         determine when the Houdini scene needs to be re-populated"]
    #[doc = "         using the host application's instances of the nodes."]
    #[doc = "         Note that this function will ALWAYS return"]
    #[doc = "         ::HAPI_RESULT_SUCCESS."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      unique_node_id"]
    #[doc = "                 The unique node id from"]
    #[doc = "                 ::HAPI_NodeInfo::uniqueHoudiniNodeId."]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::uniqueHoudiniNodeId -->"]
    #[doc = ""]
    #[doc = " @param[out]     answer"]
    #[doc = "                 Answer to the question."]
    #[doc = ""]
    pub fn HAPI_IsNodeValid(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        unique_node_id: ::std::os::raw::c_int,
        answer: *mut HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an ::HAPI_NodeInfo struct."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     node_info"]
    #[doc = "                 Return value - contains things like asset id."]
    #[doc = ""]
    pub fn HAPI_GetNodeInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        node_info: *mut HAPI_NodeInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the node absolute path in the Houdini node network or a"]
    #[doc = "         relative path any other node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      relative_to_node_id"]
    #[doc = "                 Set this to -1 to get the absolute path of the node_id."]
    #[doc = "                 Otherwise, the path will be relative to this node id."]
    #[doc = ""]
    #[doc = " @param[out]     path"]
    #[doc = "                 The returned path string, valid until the next call to"]
    #[doc = "                 this function."]
    #[doc = ""]
    pub fn HAPI_GetNodePath(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        relative_to_node_id: HAPI_NodeId,
        path: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the root node of a particular network type (ie. OBJ)."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_type"]
    #[doc = "                 The node network type."]
    #[doc = ""]
    #[doc = " @param[out]     node_id"]
    #[doc = "                 The node id of the root node network."]
    #[doc = ""]
    pub fn HAPI_GetManagerNodeId(
        session: *const HAPI_Session,
        node_type: HAPI_NodeType,
        node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Compose a list of child nodes based on given filters."]
    #[doc = ""]
    #[doc = "         This function will only compose the list of child nodes. It will"]
    #[doc = "         not return this list. After your call to this function, call"]
    #[doc = "         HAPI_GetComposedChildNodeList() to get the list of child node ids."]
    #[doc = ""]
    #[doc = "         Note: When looking for all Display SOP nodes using this function,"]
    #[doc = "         and using recursive mode, the recursion will stop as soon as a"]
    #[doc = "         display SOP is found within each OBJ geometry network. It is"]
    #[doc = "         almost never useful to get a list of ALL display SOP nodes"]
    #[doc = "         recursively as they would all containt the same geometry. Even so,"]
    #[doc = "         this special case only comes up if the display SOP itself is a"]
    #[doc = "         subnet."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The node id of the parent node."]
    #[doc = ""]
    #[doc = " @param[in]      node_type_filter"]
    #[doc = "                 The node type by which to filter the children."]
    #[doc = ""]
    #[doc = " @param[in]      node_flags_filter"]
    #[doc = "                 The node flags by which to filter the children."]
    #[doc = ""]
    #[doc = " @param[in]      recursive"]
    #[doc = "                 Whether or not to compose the list recursively."]
    #[doc = ""]
    #[doc = " @param[out]     count"]
    #[doc = "                 The number of child nodes composed. Use this as the"]
    #[doc = "                 argument to ::HAPI_GetComposedChildNodeList()."]
    #[doc = ""]
    pub fn HAPI_ComposeChildNodeList(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        node_type_filter: HAPI_NodeTypeBits,
        node_flags_filter: HAPI_NodeFlagsBits,
        recursive: HAPI_Bool,
        count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the composed list of child node ids from the previous call"]
    #[doc = "         to HAPI_ComposeChildNodeList()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The node id of the parent node."]
    #[doc = ""]
    #[doc = " @param[out]     child_node_ids_array"]
    #[doc = "                 The array of ::HAPI_NodeId for the child nodes."]
    #[doc = ""]
    #[doc = " @param[in]      count"]
    #[doc = "                 The number of children in the composed list. MUST match"]
    #[doc = "                 the count returned by HAPI_ComposeChildNodeList()."]
    #[doc = "                 <!-- source ::HAPI_ComposeChildNodeList -->"]
    #[doc = "                 <!-- min ::HAPI_ComposeChildNodeList -->"]
    #[doc = "                 <!-- max ::HAPI_ComposeChildNodeList -->"]
    #[doc = ""]
    pub fn HAPI_GetComposedChildNodeList(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        child_node_ids_array: *mut HAPI_NodeId,
        count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Create a node inside a node network. Nodes created this way"]
    #[doc = "         will have their ::HAPI_NodeInfo::createdPostAssetLoad set"]
    #[doc = "         to true."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         @note This is also when we actually check for valid licenses."]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately with a call"]
    #[doc = "         result of ::HAPI_RESULT_SUCCESS, even if fed garbage. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the creation (and, optionally, the first cook)"]
    #[doc = "         of the node has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node network's node id or -1 if the parent"]
    #[doc = "                 network is the manager (top-level) node. In that case,"]
    #[doc = "                 the manager must be identified by the table name in the"]
    #[doc = "                 operator_name."]
    #[doc = "                 <!-- min -1 -->"]
    #[doc = "                 <!-- default -1 -->"]
    #[doc = ""]
    #[doc = " @param[in]      operator_name"]
    #[doc = "                 The name of the node operator type."]
    #[doc = ""]
    #[doc = "                 If you passed parent_node_id == -1, then the operator_name"]
    #[doc = "                 has to include the table name (ie. Object/ or Sop/)."]
    #[doc = "                 This is the common case for when creating asset nodes"]
    #[doc = "                 from a loaded asset library. In that case, just pass"]
    #[doc = "                 whatever ::HAPI_GetAvailableAssets() returns."]
    #[doc = ""]
    #[doc = "                 If you have a parent_node_id then you should"]
    #[doc = "                 include only the namespace, name, and version."]
    #[doc = ""]
    #[doc = "                 For example, lets say you have an Object type asset, in"]
    #[doc = "                 the \"hapi\" namespace, of version 2.0, named \"foo\". If"]
    #[doc = "                 you pass parent_node_id == -1, then set the operator_name"]
    #[doc = "                 as \"Object/hapi::foo::2.0\". Otherwise, if you have a valid"]
    #[doc = "                 parent_node_id, then just pass operator_name as"]
    #[doc = "                 \"hapi::foo::2.0\"."]
    #[doc = ""]
    #[doc = " @param[in]      node_label"]
    #[doc = "                 (Optional) The label of the newly created node."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      cook_on_creation"]
    #[doc = "                 Set whether the node should cook once created or not."]
    #[doc = "                 <!-- default false -->"]
    #[doc = ""]
    #[doc = " @param[out]     new_node_id"]
    #[doc = "                 The returned node id of the just-created node."]
    #[doc = ""]
    pub fn HAPI_CreateNode(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        operator_name: *const ::std::os::raw::c_char,
        node_label: *const ::std::os::raw::c_char,
        cook_on_creation: HAPI_Bool,
        new_node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates a simple geometry SOP node that can accept geometry input."]
    #[doc = "         This will create a dummy OBJ node with a Null SOP inside that"]
    #[doc = "         you can set the geometry of using the geometry SET APIs."]
    #[doc = "         You can then connect this node to any other node as a geometry"]
    #[doc = "         input."]
    #[doc = ""]
    #[doc = "         Note that when saving the Houdini scene using"]
    #[doc = "         ::HAPI_SaveHIPFile() the nodes created with this"]
    #[doc = "         method will be green and will start with the name \"input\"."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     node_id"]
    #[doc = "                 Newly created node's id. Use ::HAPI_GetNodeInfo()"]
    #[doc = "                 to get more information about the node."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Give this input node a name for easy debugging."]
    #[doc = "                 The node's parent OBJ node and the Null SOP node will both"]
    #[doc = "                 get this given name with \"input_\" prepended."]
    #[doc = "                 You can also pass NULL in which case the name will"]
    #[doc = "                 be \"input#\" where # is some number."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    pub fn HAPI_CreateInputNode(
        session: *const HAPI_Session,
        node_id: *mut HAPI_NodeId,
        name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates the required node hierarchy needed for Heightfield inputs."]
    #[doc = ""]
    #[doc = "         Note that when saving the Houdini scene using"]
    #[doc = "         ::HAPI_SaveHIPFile() the nodes created with this"]
    #[doc = "         method will be green and will start with the name \"input\"."]
    #[doc = ""]
    #[doc = "         Note also that this uses center sampling. Use"]
    #[doc = "         ::HAPI_CreateHeightfieldInput to specify corner sampling."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node network's node id or -1 if the parent"]
    #[doc = "                 network is the manager (top-level) node. In that case,"]
    #[doc = "                 the manager must be identified by the table name in the"]
    #[doc = "                 operator_name."]
    #[doc = "                 <!-- min -1 -->"]
    #[doc = "                 <!-- default -1 -->"]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Give this input node a name for easy debugging."]
    #[doc = "                 The node's parent OBJ node and the Null SOP node will both"]
    #[doc = "                 get this given name with \"input_\" prepended."]
    #[doc = "                 You can also pass NULL in which case the name will"]
    #[doc = "                 be \"input#\" where # is some number."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      xsize"]
    #[doc = "                 size of the heightfield in X"]
    #[doc = ""]
    #[doc = " @param[in]      ysize"]
    #[doc = "                 size of the heightfield in y"]
    #[doc = ""]
    #[doc = " @param[in]      voxelsize"]
    #[doc = "                 Size of the voxel"]
    #[doc = ""]
    #[doc = " @param[out]     heightfield_node_id"]
    #[doc = "                 Newly created node id for the Heightfield node."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about"]
    #[doc = "                 the node."]
    #[doc = ""]
    #[doc = " @param[out]     height_node_id"]
    #[doc = "                 Newly created node id for the height volume."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the node."]
    #[doc = ""]
    #[doc = " @param[out]     mask_node_id"]
    #[doc = "                 Newly created node id for the mask volume."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the"]
    #[doc = "                 node."]
    #[doc = ""]
    #[doc = " @param[out]     merge_node_id"]
    #[doc = "                 Newly created merge node id."]
    #[doc = "                 The merge node can be used to connect additional input masks."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the node."]
    #[doc = ""]
    pub fn HAPI_CreateHeightfieldInputNode(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        name: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        voxelsize: f32,
        heightfield_node_id: *mut HAPI_NodeId,
        height_node_id: *mut HAPI_NodeId,
        mask_node_id: *mut HAPI_NodeId,
        merge_node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates the required node hierarchy needed for heightfield inputs."]
    #[doc = ""]
    #[doc = "         Note that when saving the Houdini scene using"]
    #[doc = "         ::HAPI_SaveHIPFile() the nodes created with this"]
    #[doc = "         method will be green and will start with the name \"input\"."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node network's node id or -1 if the parent"]
    #[doc = "                 network is the manager (top-level) node. In that case,"]
    #[doc = "                 the manager must be identified by the table name in the"]
    #[doc = "                 operator_name."]
    #[doc = "                 <!-- min -1 -->"]
    #[doc = "                 <!-- default -1 -->"]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Give this input node a name for easy debugging."]
    #[doc = "                 The node's parent OBJ node and the Null SOP node will both"]
    #[doc = "                 get this given name with \"input_\" prepended."]
    #[doc = "                 You can also pass NULL in which case the name will"]
    #[doc = "                 be \"input#\" where # is some number."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      xsize"]
    #[doc = "                 size of the heightfield in X"]
    #[doc = ""]
    #[doc = " @param[in]      ysize"]
    #[doc = "                 size of the heightfield in y"]
    #[doc = ""]
    #[doc = " @param[in]      voxelsize"]
    #[doc = "                 Size of the voxel"]
    #[doc = ""]
    #[doc = " @param[in]      sampling"]
    #[doc = "                 Type of sampling which should be either center or corner."]
    #[doc = ""]
    #[doc = " @param[out]     heightfield_node_id"]
    #[doc = "                 Newly created node id for the heightfield node."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about"]
    #[doc = "                 the node."]
    #[doc = ""]
    #[doc = " @param[out]     height_node_id"]
    #[doc = "                 Newly created node id for the height volume."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the node."]
    #[doc = ""]
    #[doc = " @param[out]     mask_node_id"]
    #[doc = "                 Newly created node id for the mask volume."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the"]
    #[doc = "                 node."]
    #[doc = ""]
    #[doc = " @param[out]     merge_node_id"]
    #[doc = "                 Newly created merge node id."]
    #[doc = "                 The merge node can be used to connect additional input masks."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the node."]
    #[doc = ""]
    pub fn HAPI_CreateHeightFieldInput(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        name: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        voxelsize: f32,
        sampling: HAPI_HeightFieldSampling,
        heightfield_node_id: *mut HAPI_NodeId,
        height_node_id: *mut HAPI_NodeId,
        mask_node_id: *mut HAPI_NodeId,
        merge_node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Creates a volume input node that can be used with Heightfields"]
    #[doc = ""]
    #[doc = "         Note that when saving the Houdini scene using"]
    #[doc = "         ::HAPI_SaveHIPFile() the nodes created with this"]
    #[doc = "         method will be green and will start with the name \"input\"."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node network's node id or -1 if the parent"]
    #[doc = "                 network is the manager (top-level) node. In that case,"]
    #[doc = "                 the manager must be identified by the table name in the"]
    #[doc = "                 operator_name."]
    #[doc = "                 <!-- min -1 -->"]
    #[doc = "                 <!-- default -1 -->"]
    #[doc = ""]
    #[doc = " @param[out]     new_node_id"]
    #[doc = "                 Newly created node id for the volume."]
    #[doc = "                 Use ::HAPI_GetNodeInfo() to get more information about the"]
    #[doc = "                 node."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 The name of the volume to create."]
    #[doc = "                 You can also pass NULL in which case the name will"]
    #[doc = "                 be \"input#\" where # is some number."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      xsize"]
    #[doc = "                 size of the heightfield in X"]
    #[doc = ""]
    #[doc = " @param[in]      ysize"]
    #[doc = "                 size of the heightfield in y"]
    #[doc = ""]
    #[doc = " @param[in]      voxelsize"]
    #[doc = "                 Size of the voxel"]
    #[doc = ""]
    pub fn HAPI_CreateHeightfieldInputVolumeNode(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        new_node_id: *mut HAPI_NodeId,
        name: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        voxelsize: f32,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Initiate a cook on this node. Note that this may trigger"]
    #[doc = "         cooks on other nodes if they are connected."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      cook_options"]
    #[doc = "                 The cook options. Pass in NULL to use the global"]
    #[doc = "                 cook options that you specified when calling"]
    #[doc = "                 ::HAPI_Initialize()."]
    #[doc = ""]
    pub fn HAPI_CookNode(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        cook_options: *const HAPI_CookOptions,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Delete a node from a node network. Only nodes with their"]
    #[doc = "         ::HAPI_NodeInfo::createdPostAssetLoad set to true can be"]
    #[doc = "         deleted this way."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node to delete."]
    #[doc = ""]
    pub fn HAPI_DeleteNode(session: *const HAPI_Session, node_id: HAPI_NodeId) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Rename a node that you created. Only nodes with their"]
    #[doc = "         ::HAPI_NodeInfo::createdPostAssetLoad set to true can be"]
    #[doc = "         renamed this way."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node to rename."]
    #[doc = ""]
    #[doc = " @param[in]      new_name"]
    #[doc = "                 The new node name."]
    #[doc = ""]
    pub fn HAPI_RenameNode(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        new_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Connect two nodes together."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node whom's input to connect to."]
    #[doc = ""]
    #[doc = " @param[in]      input_index"]
    #[doc = "                 The input index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::inputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id_to_connect"]
    #[doc = "                 The node to connect to node_id's input."]
    #[doc = ""]
    #[doc = " @param[in]\t    output_index"]
    #[doc = "                 The output index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::outputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = ""]
    pub fn HAPI_ConnectNodeInput(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        input_index: ::std::os::raw::c_int,
        node_id_to_connect: HAPI_NodeId,
        output_index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Disconnect a node input."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node whom's input to disconnect."]
    #[doc = ""]
    #[doc = " @param[in]      input_index"]
    #[doc = "                 The input index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::inputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = ""]
    pub fn HAPI_DisconnectNodeInput(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        input_index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Query which node is connected to another node's input."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_to_query"]
    #[doc = "                 The node to query."]
    #[doc = ""]
    #[doc = " @param[in]      input_index"]
    #[doc = "                 The input index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::inputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = ""]
    #[doc = " @param[out]     connected_node_id"]
    #[doc = "                 The node id of the connected node to this input. If"]
    #[doc = "                 nothing is connected then -1 will be returned."]
    #[doc = ""]
    pub fn HAPI_QueryNodeInput(
        session: *const HAPI_Session,
        node_to_query: HAPI_NodeId,
        input_index: ::std::os::raw::c_int,
        connected_node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the name of an node's input. This function will return"]
    #[doc = "         a string handle for the name which will be valid (persist)"]
    #[doc = "         until the next call to this function."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      input_idx"]
    #[doc = "                 The input index. Should be between 0 and the"]
    #[doc = "                 node_to_query's ::HAPI_NodeInfo::inputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = ""]
    #[doc = " @param[out]     name"]
    #[doc = "                 Input name string handle return value - valid until"]
    #[doc = "                 the next call to this function."]
    #[doc = ""]
    pub fn HAPI_GetNodeInputName(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        input_idx: ::std::os::raw::c_int,
        name: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Disconnect all of the node's output connections at the output index."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node whom's outputs to disconnect."]
    #[doc = ""]
    #[doc = " @param[in]      output_index"]
    #[doc = "                 The output index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::outputCount."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = ""]
    pub fn HAPI_DisconnectNodeOutputsAt(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        output_index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the number of nodes currently connected to the given node at"]
    #[doc = "\t    the output index."]
    #[doc = ""]
    #[doc = "         Use the @c count returned by this function to get the"]
    #[doc = "         ::HAPI_NodeIds of connected nodes using"]
    #[doc = "         ::HAPI_QueryNodeOutputConnectedNodes()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      output_idx"]
    #[doc = "                 The output index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::outputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::outputCount - 1 -->"]
    #[doc = ""]
    #[doc = " @param[in]      into_subnets"]
    #[doc = "                 Whether to search by diving into subnets."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[in]      through_dots"]
    #[doc = "                 Whether to search through dots."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[out]     connected_count"]
    #[doc = "                 The number of nodes currently connected to this node at"]
    #[doc = "                 given output index. Use this count with a call to"]
    #[doc = "                 ::HAPI_QueryNodeOutputConnectedNodes() to get list of"]
    #[doc = "                 connected nodes."]
    #[doc = ""]
    pub fn HAPI_QueryNodeOutputConnectedCount(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        output_idx: ::std::os::raw::c_int,
        into_subnets: HAPI_Bool,
        through_dots: HAPI_Bool,
        connected_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the ids of nodes currently connected to the given node"]
    #[doc = "\t    at the output index."]
    #[doc = ""]
    #[doc = "         Use the @c connected_count returned by"]
    #[doc = "\t    ::HAPI_QueryNodeOutputConnectedCount()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      output_idx"]
    #[doc = "                 The output index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::outputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::outputCount - 1 -->"]
    #[doc = ""]
    #[doc = " @param[in]      into_subnets"]
    #[doc = "                 Whether to search by diving into subnets."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[in]      through_dots"]
    #[doc = "                 Whether to search through dots."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[out]     connected_node_ids_array"]
    #[doc = "\t\t            Array of ::HAPI_NodeId at least the size of @c length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 At least @c 0 and at most @c connected_count returned by"]
    #[doc = "                 ::HAPI_QueryNodeOutputConnectedCount()."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_QueryNodeOutputConnectedCount -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Given @c connected_count returned by"]
    #[doc = "                 ::HAPI_QueryNodeOutputConnectedCount(), @c length should"]
    #[doc = "                 be at least @c 1 and at most <tt>connected_count - start</tt>."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_QueryNodeOutputConnectedCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_QueryNodeOutputConnectedCount - start -->"]
    #[doc = ""]
    pub fn HAPI_QueryNodeOutputConnectedNodes(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        output_idx: ::std::os::raw::c_int,
        into_subnets: HAPI_Bool,
        through_dots: HAPI_Bool,
        connected_node_ids_array: *mut HAPI_NodeId,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the name of an node's output. This function will return"]
    #[doc = "         a string handle for the name which will be valid (persist)"]
    #[doc = "         until the next call to this function."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      output_idx"]
    #[doc = "                 The output index. Should be between 0 and the"]
    #[doc = "                 to_node's ::HAPI_NodeInfo::outputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::outputCount - 1 -->"]
    #[doc = ""]
    #[doc = " @param[out]     name"]
    #[doc = "                 Output name string handle return value - valid until"]
    #[doc = "                 the next call to this function."]
    #[doc = ""]
    pub fn HAPI_GetNodeOutputName(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        output_idx: ::std::os::raw::c_int,
        name: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief Gets the node id of an output node in a SOP network."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id of a SOP node with at least one output node. The"]
    #[doc = "                 total number of node outputs can be found from the node's"]
    #[doc = "                 ::HAPI_NodeInfo::outputCount"]
    #[doc = ""]
    #[doc = " @param[in]      output"]
    #[doc = "                 The output index. Should be between 0 and the node's"]
    #[doc = "                 ::HAPI_NodeInfo::outputCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::outputCount - 1 -->"]
    #[doc = ""]
    #[doc = " @param[out]     output_node_id"]
    #[doc = "                 Pointer to a HAPI_NodeId where the node id of the output"]
    #[doc = "                 node will be stored."]
    pub fn HAPI_GetOutputNodeId(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        output: ::std::os::raw::c_int,
        output_node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_ParmInfo structs with parameter"]
    #[doc = "         information from the asset instance node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     parm_infos_array"]
    #[doc = "                 Array of ::HAPI_ParmInfo at least the size of"]
    #[doc = "                 length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmCount - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmCount - start."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::parmCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetParameters(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_infos_array: *mut HAPI_ParmInfo,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the parm info of a parameter by parm id."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 The parm id."]
    #[doc = ""]
    #[doc = " @param[out]     parm_info"]
    #[doc = "                 The returned parm info."]
    #[doc = ""]
    pub fn HAPI_GetParmInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        parm_info: *mut HAPI_ParmInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  All parameter APIs require a ::HAPI_ParmId but if you know the"]
    #[doc = "         parameter you wish to operate on by name than you can use"]
    #[doc = "         this function to get its ::HAPI_ParmId. If the parameter with"]
    #[doc = "         the given name is not found the parameter id returned"]
    #[doc = "         will be -1."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[out]     parm_id"]
    #[doc = "                 The return value. The parameter's ::HAPI_ParmId. If"]
    #[doc = "                 the parameter with the given name is not found the"]
    #[doc = "                 parameter id returned will be -1."]
    #[doc = ""]
    pub fn HAPI_GetParmIdFromName(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        parm_id: *mut HAPI_ParmId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the parm info of a parameter by name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[out]     parm_info"]
    #[doc = "                 The returned parm info."]
    #[doc = ""]
    pub fn HAPI_GetParmInfoFromName(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        parm_info: *mut HAPI_ParmInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the tag name on a parameter given an index."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 The parm id."]
    #[doc = ""]
    #[doc = " @param[in]      tag_index"]
    #[doc = "                 The tag index, which should be between 0 and"]
    #[doc = "                 ::HAPI_ParmInfo::tagCount - 1."]
    #[doc = "                 @note These indices are invalidated whenever tags are added"]
    #[doc = "                 to parameters. Do not store these or expect them to be the"]
    #[doc = "                 same if the scene is modified."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_ParmInfo::tagCount - 1 -->"]
    #[doc = ""]
    #[doc = " @param[out]     tag_name"]
    #[doc = "                 The returned tag name. This string handle will be valid"]
    #[doc = "                 until another call to ::HAPI_GetParmTagName()."]
    #[doc = ""]
    pub fn HAPI_GetParmTagName(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        tag_index: ::std::os::raw::c_int,
        tag_name: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the tag value on a parameter given the tag name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 The parm id."]
    #[doc = ""]
    #[doc = " @param[in]      tag_name"]
    #[doc = "                 The tag name, either known or returned by"]
    #[doc = "                 ::HAPI_GetParmTagName()."]
    #[doc = ""]
    #[doc = " @param[out]     tag_value"]
    #[doc = "                 The returned tag value. This string handle will be valid"]
    #[doc = "                 until another call to ::HAPI_GetParmTagValue()."]
    #[doc = ""]
    pub fn HAPI_GetParmTagValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        tag_name: *const ::std::os::raw::c_char,
        tag_value: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  See if a parameter has a specific tag."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 The parm id."]
    #[doc = ""]
    #[doc = " @param[in]      tag_name"]
    #[doc = "                 The tag name to look for."]
    #[doc = ""]
    #[doc = " @param[out]     has_tag"]
    #[doc = "                 True if the tag exists on the parameter, false otherwise."]
    #[doc = ""]
    pub fn HAPI_ParmHasTag(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        tag_name: *const ::std::os::raw::c_char,
        has_tag: *mut HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  See if a parameter has an expression"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 The parm index."]
    #[doc = ""]
    #[doc = " @param[out]     has_expression"]
    #[doc = "                 True if an expression exists on the parameter, false otherwise."]
    #[doc = ""]
    pub fn HAPI_ParmHasExpression(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        has_expression: *mut HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the first parm with a specific, ideally unique, tag on it."]
    #[doc = "         This is particularly useful for getting the ogl parameters on a"]
    #[doc = "         material node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      tag_name"]
    #[doc = "                 The tag name to look for."]
    #[doc = ""]
    #[doc = " @param[out]     parm_id"]
    #[doc = "                 The returned parm id. This will be -1 if no parm was found"]
    #[doc = "                 with this tag."]
    #[doc = ""]
    pub fn HAPI_GetParmWithTag(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        tag_name: *const ::std::os::raw::c_char,
        parm_id: *mut HAPI_ParmId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get single integer or float parm expression by name"]
    #[doc = "         or Null string if no expression is present"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The returned string value."]
    #[doc = ""]
    pub fn HAPI_GetParmExpression(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        value: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Revert single parm by name to default"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    pub fn HAPI_RevertParmToDefault(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Revert all instances of the parm by name to defaults"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    pub fn HAPI_RevertParmToDefaults(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set (push) an expression string. We can only set a single value at"]
    #[doc = "         a time because we want to avoid fixed size string buffers."]
    #[doc = ""]
    #[doc = "         @note Regardless of the value, when calling this function"]
    #[doc = "         on a parameter, if that parameter has a callback function"]
    #[doc = "         attached to it, that callback function will be called. For"]
    #[doc = "         example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The expression string."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 Parameter id of the parameter being updated."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    pub fn HAPI_SetParmExpression(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        value: *const ::std::os::raw::c_char,
        parm_id: HAPI_ParmId,
        index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Remove the expression string, leaving the value of the"]
    #[doc = "         parm at the current value of the expression"]
    #[doc = ""]
    #[doc = "         @note Regardless of the value, when calling this function"]
    #[doc = "         on a parameter, if that parameter has a callback function"]
    #[doc = "         attached to it, that callback function will be called. For"]
    #[doc = "         example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 Parameter id of the parameter being updated."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    pub fn HAPI_RemoveParmExpression(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get single parm int value by name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The returned int value."]
    #[doc = ""]
    pub fn HAPI_GetParmIntValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of parameter int values. This is more efficient"]
    #[doc = "         than calling ::HAPI_GetParmIntValue() individually for each"]
    #[doc = "         parameter value."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 Array of ints at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmIntValueCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmIntValueCount - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmIntValueCount - start."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmIntValueCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::parmIntValueCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetParmIntValues(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        values_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get single parm float value by name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The returned float value."]
    #[doc = ""]
    pub fn HAPI_GetParmFloatValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        value: *mut f32,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of parameter float values. This is more efficient"]
    #[doc = "         than calling ::HAPI_GetParmFloatValue() individually for each"]
    #[doc = "         parameter value."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 Array of floats at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmFloatValueCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmFloatValueCount - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmFloatValueCount - start."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmFloatValueCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::parmFloatValueCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetParmFloatValues(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        values_array: *mut f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get single parm string value by name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The name of the parameter."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    #[doc = " @param[in]      evaluate"]
    #[doc = "                 Whether or not to evaluate the string expression."]
    #[doc = "                 For example, the string \"$F\" would evaluate to the"]
    #[doc = "                 current frame number. So, passing in evaluate = false"]
    #[doc = "                 would give you back the string \"$F\" and passing"]
    #[doc = "                 in evaluate = true would give you back \"1\" (assuming"]
    #[doc = "                 the current frame is 1)."]
    #[doc = "                 <!-- default true -->"]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The returned string value."]
    #[doc = ""]
    pub fn HAPI_GetParmStringValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        evaluate: HAPI_Bool,
        value: *mut HAPI_StringHandle,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of parameter string handles. These handles must"]
    #[doc = "         be used in conjunction with ::HAPI_GetString() to get the"]
    #[doc = "         actual string values. This is more efficient than calling"]
    #[doc = "         ::HAPI_GetParmStringValue() individually for each"]
    #[doc = "         parameter value."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      evaluate"]
    #[doc = "                 Whether or not to evaluate the string expression."]
    #[doc = "                 For example, the string \"$F\" would evaluate to the"]
    #[doc = "                 current frame number. So, passing in evaluate = false"]
    #[doc = "                 would give you back the string \"$F\" and passing"]
    #[doc = "                 in evaluate = true would give you back \"1\" (assuming"]
    #[doc = "                 the current frame is 1)."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 Array of integers at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmStringValueCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmStringValueCount - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmStringValueCount - start."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmStringValueCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::parmStringValueCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetParmStringValues(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        evaluate: HAPI_Bool,
        values_array: *mut HAPI_StringHandle,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get a single node id parm value of an Op Path parameter. This is"]
    #[doc = "         how you see which node is connected as an input for the current"]
    #[doc = "         node (via parameter)."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The name of the parameter."]
    #[doc = ""]
    #[doc = " @param[out]     value"]
    #[doc = "                 The node id of the node being pointed to by the parm."]
    #[doc = "                 If there is no node found, -1 will be returned."]
    #[doc = ""]
    pub fn HAPI_GetParmNodeValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        value: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Extract a file specified by path on a parameter. This will copy"]
    #[doc = "         the file to the destination directory from wherever it might be,"]
    #[doc = "         inlcuding inside the asset definition or online."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The name of the parameter."]
    #[doc = ""]
    #[doc = " @param[in]      destination_directory"]
    #[doc = "                 The destination directory to copy the file to."]
    #[doc = ""]
    #[doc = " @param[in]      destination_file_name"]
    #[doc = "                 The destination file name."]
    #[doc = ""]
    pub fn HAPI_GetParmFile(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        destination_directory: *const ::std::os::raw::c_char,
        destination_file_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_ParmChoiceInfo structs with parameter"]
    #[doc = "         choice list information from the asset instance node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     parm_choices_array"]
    #[doc = "                 Array of ::HAPI_ParmChoiceInfo exactly the size of"]
    #[doc = "                 length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmChoiceCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmChoiceCount - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmChoiceCount - start."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmChoiceCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::parmChoiceCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetParmChoiceLists(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_choices_array: *mut HAPI_ParmChoiceInfo,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set single parm int value by name."]
    #[doc = ""]
    #[doc = "         @note Regardless of the value, when calling this function"]
    #[doc = "         on a parameter, if that parameter has a callback function"]
    #[doc = "         attached to it, that callback function will be called. For"]
    #[doc = "         example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The int value."]
    #[doc = ""]
    pub fn HAPI_SetParmIntValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set (push) an array of parameter int values."]
    #[doc = ""]
    #[doc = "         @note Regardless of the values, when calling this function"]
    #[doc = "         on a set of parameters, if any parameter has a callback"]
    #[doc = "         function attached to it, that callback function will be called."]
    #[doc = "         For example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      values_array"]
    #[doc = "                 Array of integers at least the size of length."]
    #[doc = "                 <!-- min length -->"]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmIntValueCount - 1."]
    #[doc = "                 <!-- min 0 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmIntValueCount - 1 -->"]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmIntValueCount - start."]
    #[doc = "                 <!-- min 1 -->"]
    #[doc = "                 <!-- max ::HAPI_NodeInfo::parmIntValueCount - start -->"]
    #[doc = "                 <!-- source ::HAPI_NodeInfo::parmIntValueCount - start -->"]
    #[doc = ""]
    pub fn HAPI_SetParmIntValues(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        values_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set single parm float value by name."]
    #[doc = ""]
    #[doc = "         @note Regardless of the value, when calling this function"]
    #[doc = "         on a parameter, if that parameter has a callback function"]
    #[doc = "         attached to it, that callback function will be called. For"]
    #[doc = "         example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The parm name."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The float value."]
    #[doc = ""]
    pub fn HAPI_SetParmFloatValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        value: f32,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set (push) an array of parameter float values."]
    #[doc = ""]
    #[doc = "         @note Regardless of the values, when calling this function"]
    #[doc = "         on a set of parameters, if any parameter has a callback"]
    #[doc = "         function attached to it, that callback function will be called."]
    #[doc = "         For example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      values_array"]
    #[doc = "                 Array of floats at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_NodeInfo::parmFloatValueCount - 1."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_NodeInfo::parmFloatValueCount - start."]
    #[doc = ""]
    pub fn HAPI_SetParmFloatValues(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        values_array: *const f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set (push) a string value. We can only set a single value at"]
    #[doc = "         a time because we want to avoid fixed size string buffers."]
    #[doc = ""]
    #[doc = "         @note Regardless of the value, when calling this function"]
    #[doc = "         on a parameter, if that parameter has a callback function"]
    #[doc = "         attached to it, that callback function will be called. For"]
    #[doc = "         example, if the parameter is a button the button will be"]
    #[doc = "         pressed."]
    #[doc = ""]
    #[doc = "         @note In threaded mode, this is an _async call_!"]
    #[doc = ""]
    #[doc = "         This API will invoke the cooking thread if threading is"]
    #[doc = "         enabled. This means it will return immediately. Use"]
    #[doc = "         the status and cooking count APIs under DIAGNOSTICS to get"]
    #[doc = "         a sense of the progress. All other API calls will block"]
    #[doc = "         until the cook operation has finished."]
    #[doc = ""]
    #[doc = "         Also note that the cook result won't be of type"]
    #[doc = "         ::HAPI_STATUS_CALL_RESULT like all calls (including this one)."]
    #[doc = "         Whenever the threading cook is done it will fill the"]
    #[doc = "         @a cook result which is queried using"]
    #[doc = "         ::HAPI_STATUS_COOK_RESULT."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The string value."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 Parameter id of the parameter being updated."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 Index within the parameter's values tuple."]
    #[doc = ""]
    pub fn HAPI_SetParmStringValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        value: *const ::std::os::raw::c_char,
        parm_id: HAPI_ParmId,
        index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set a node id parm value of an Op Path parameter. For example,"]
    #[doc = "         This is how you connect the geometry output of an asset to the"]
    #[doc = "         geometry input of another asset - whether the input is a parameter"]
    #[doc = "         or a node input (the top of the node). Node inputs get converted"]
    #[doc = "         top parameters in HAPI."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_name"]
    #[doc = "                 The name of the parameter."]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 The node id of the node being connected. Pass -1 to"]
    #[doc = "                 disconnect."]
    #[doc = ""]
    pub fn HAPI_SetParmNodeValue(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_name: *const ::std::os::raw::c_char,
        value: HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief Insert an instance of a multiparm before instance_position."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 A parm id given by a ::HAPI_ParmInfo struct that"]
    #[doc = "                 has type ::HAPI_PARMTYPE_MULTIPARMLIST."]
    #[doc = ""]
    #[doc = " @param[in]      instance_position"]
    #[doc = "                 The new instance will be inserted at this position"]
    #[doc = "                 index. Do note the multiparms can start at position"]
    #[doc = "                 1 or 0. Use ::HAPI_ParmInfo::instanceStartOffset to"]
    #[doc = "                 distinguish."]
    #[doc = ""]
    pub fn HAPI_InsertMultiparmInstance(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        instance_position: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief Remove the instance of a multiparm given by instance_position."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 A parm id given by a ::HAPI_ParmInfo struct that"]
    #[doc = "                 has type ::HAPI_PARMTYPE_MULTIPARMLIST."]
    #[doc = ""]
    #[doc = " @param[in]      instance_position"]
    #[doc = "                 The instance at instance_position will removed."]
    #[doc = ""]
    pub fn HAPI_RemoveMultiparmInstance(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        instance_position: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_HandleInfo structs with information"]
    #[doc = "         about every exposed user manipulation handle on the node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     handle_infos_array"]
    #[doc = "                 Array of ::HAPI_HandleInfo at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AssetInfo::handleCount - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_AssetInfo::handleCount - start."]
    #[doc = "                 <!-- source ::HAPI_AssetInfo::handleCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetHandleInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        handle_infos_array: *mut HAPI_HandleInfo,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_HandleBindingInfo structs with information"]
    #[doc = "         about the binding of a particular handle on the given node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      handle_index"]
    #[doc = "                 The index of the handle, from 0 to handleCount - 1"]
    #[doc = "                 from the call to ::HAPI_GetAssetInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     handle_binding_infos_array"]
    #[doc = "                 Array of ::HAPI_HandleBindingInfo at least the size"]
    #[doc = "                 of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_HandleInfo::bindingsCount - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 1 and at most"]
    #[doc = "                 ::HAPI_HandleInfo::bindingsCount - start."]
    #[doc = "                 <!-- source ::HAPI_AssetInfo::bindingsCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetHandleBindingInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        handle_index: ::std::os::raw::c_int,
        handle_binding_infos_array: *mut HAPI_HandleBindingInfo,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Generate a preset blob of the current state of all the"]
    #[doc = "         parameter values, cache it, and return its size in bytes."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The exposed node id."]
    #[doc = ""]
    #[doc = " @param[in]      preset_type"]
    #[doc = "                 The preset type."]
    #[doc = ""]
    #[doc = " @param[in]      preset_name"]
    #[doc = "                 Optional. This is only used if the @p preset_type is"]
    #[doc = "                 ::HAPI_PRESETTYPE_IDX. If NULL is given, the preset"]
    #[doc = "                 name will be the same as the name of the node with"]
    #[doc = "                 the given @p node_id."]
    #[doc = ""]
    #[doc = " @param[out]     buffer_length"]
    #[doc = "                 Size of the buffer."]
    #[doc = ""]
    pub fn HAPI_GetPresetBufLength(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        preset_type: HAPI_PresetType,
        preset_name: *const ::std::os::raw::c_char,
        buffer_length: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Generates a preset for the given asset."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The exposed node id."]
    #[doc = ""]
    #[doc = " @param[out]     buffer"]
    #[doc = "                 Buffer to hold the preset data."]
    #[doc = ""]
    #[doc = " @param[in]      buffer_length"]
    #[doc = "                 Size of the buffer. Should be the same as the length"]
    #[doc = "                 returned by ::HAPI_GetPresetBufLength()."]
    #[doc = ""]
    pub fn HAPI_GetPreset(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Sets a particular asset to a given preset."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The exposed node id."]
    #[doc = ""]
    #[doc = " @param[in]      preset_type"]
    #[doc = "                 The preset type."]
    #[doc = ""]
    #[doc = " @param[in]      preset_name"]
    #[doc = "                 Optional. This is only used if the @p preset_type is"]
    #[doc = "                 ::HAPI_PRESETTYPE_IDX. If NULL is give, the first"]
    #[doc = "                 preset in the IDX file will be chosen."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      buffer"]
    #[doc = "                 Buffer to hold the preset data."]
    #[doc = ""]
    #[doc = " @param[in]      buffer_length"]
    #[doc = "                 Size of the buffer."]
    #[doc = ""]
    pub fn HAPI_SetPreset(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        preset_type: HAPI_PresetType,
        preset_name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_char,
        buffer_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the object info on an OBJ node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     object_info"]
    #[doc = "                 The output ::HAPI_ObjectInfo."]
    #[doc = ""]
    pub fn HAPI_GetObjectInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        object_info: *mut HAPI_ObjectInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the tranform of an OBJ node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The object node id."]
    #[doc = ""]
    #[doc = " @param[in]      relative_to_node_id"]
    #[doc = "                 The object node id for the object to which the returned"]
    #[doc = "                 transform will be relative to. Pass -1 or the node_id"]
    #[doc = "                 to just get the object's local transform."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The order of application of translation, rotation and"]
    #[doc = "                 scale."]
    #[doc = ""]
    #[doc = " @param[out]     transform"]
    #[doc = "                 The output ::HAPI_Transform transform."]
    #[doc = ""]
    pub fn HAPI_GetObjectTransform(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        relative_to_node_id: HAPI_NodeId,
        rst_order: HAPI_RSTOrder,
        transform: *mut HAPI_Transform,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Compose a list of child object nodes given a parent node id."]
    #[doc = ""]
    #[doc = "         Use the @c object_count returned by this function to get the"]
    #[doc = "         ::HAPI_ObjectInfo structs for each child object using"]
    #[doc = "         ::HAPI_GetComposedObjectList()."]
    #[doc = ""]
    #[doc = "         Note, if not using the @c categories arg, this is equivalent to:"]
    #[doc = "         @code"]
    #[doc = "         HAPI_ComposeChildNodeList("]
    #[doc = "             session, parent_node_id,"]
    #[doc = "             HAPI_NODETYPE_OBJ,"]
    #[doc = "             HAPI_NODEFLAGS_OBJ_GEOMETRY,"]
    #[doc = "             true, &object_count );"]
    #[doc = "         @endcode"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node id."]
    #[doc = ""]
    #[doc = " @param[in]      categories"]
    #[doc = "                 (Optional) Lets you filter object nodes by their render"]
    #[doc = "                 categories. This is a standard OBJ parameter, usually"]
    #[doc = "                 under the Render > Shading tab. If an OBJ node does not"]
    #[doc = "                 have this parameter, one can always add it as a spare."]
    #[doc = ""]
    #[doc = "                 The value of this string argument should be NULL if not"]
    #[doc = "                 used or a space-separated list of category names."]
    #[doc = "                 Multiple category names will be treated as an AND op."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     object_count"]
    #[doc = "                 The number of object nodes currently under the parent."]
    #[doc = "                 Use this count with a call to"]
    #[doc = "                 ::HAPI_GetComposedObjectList() to get the object infos."]
    #[doc = ""]
    pub fn HAPI_ComposeObjectList(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        categories: *const ::std::os::raw::c_char,
        object_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_ObjectInfo structs."]
    #[doc = ""]
    #[doc = "         This is best used with ::HAPI_ComposeObjectList() with."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node id."]
    #[doc = ""]
    #[doc = " @param[out]     object_infos_array"]
    #[doc = "                 Array of ::HAPI_ObjectInfo at least the size of"]
    #[doc = "                 @c length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 At least @c 0 and at most @c object_count returned by"]
    #[doc = "                 ::HAPI_ComposeObjectList()."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Given @c object_count returned by"]
    #[doc = "                 ::HAPI_ComposeObjectList(), @c length should be at least"]
    #[doc = "                 @c 0 and at most <tt>object_count - start</tt>."]
    #[doc = "                 <!-- source ::HAPI_ComposeObjectList - start -->"]
    #[doc = ""]
    pub fn HAPI_GetComposedObjectList(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        object_infos_array: *mut HAPI_ObjectInfo,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_Transform structs."]
    #[doc = ""]
    #[doc = "         This is best used with ::HAPI_ComposeObjectList() with."]
    #[doc = ""]
    #[doc = "         Note that these transforms will be relative to the"]
    #[doc = "         @c parent_node_id originally given to ::HAPI_ComposeObjectList()"]
    #[doc = "         and expected to be the same with this call. If @c parent_node_id"]
    #[doc = "         is not an OBJ node, the transforms will be given as they are on"]
    #[doc = "         the object node itself."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node id. The object transforms will be"]
    #[doc = "                 relative to this node unless this node is not an OBJ."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The order of application of translation, rotation and"]
    #[doc = "                 scale."]
    #[doc = ""]
    #[doc = " @param[out]     transform_array"]
    #[doc = "                 Array of ::HAPI_Transform at least the size of"]
    #[doc = "                 length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 At least @c 0 and at most @c object_count returned by"]
    #[doc = "                 ::HAPI_ComposeObjectList()."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Given @c object_count returned by"]
    #[doc = "                 ::HAPI_ComposeObjectList(), @c length should be at least"]
    #[doc = "                 @c 0 and at most <tt>object_count - start</tt>."]
    #[doc = "                 <!-- source ::HAPI_ComposeObjectList - start -->"]
    #[doc = ""]
    pub fn HAPI_GetComposedObjectTransforms(
        session: *const HAPI_Session,
        parent_node_id: HAPI_NodeId,
        rst_order: HAPI_RSTOrder,
        transform_array: *mut HAPI_Transform,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the node ids for the objects being instanced by an"]
    #[doc = "         Instance OBJ node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      object_node_id"]
    #[doc = "                 The object node id."]
    #[doc = ""]
    #[doc = " @param[out]     instanced_node_id_array"]
    #[doc = "                 Array of ::HAPI_NodeId at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 At least @c 0 and at most @c object_count returned by"]
    #[doc = "                 ::HAPI_ComposeObjectList()."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Given @c object_count returned by"]
    #[doc = "                 ::HAPI_ComposeObjectList(), @c length should be at least"]
    #[doc = "                 @c 0 and at most <tt>object_count - start</tt>."]
    #[doc = "                 <!-- source ::HAPI_ComposeObjectList - start -->"]
    #[doc = ""]
    pub fn HAPI_GetInstancedObjectIds(
        session: *const HAPI_Session,
        object_node_id: HAPI_NodeId,
        instanced_node_id_array: *mut HAPI_NodeId,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_Transform structs with the transforms"]
    #[doc = "         of each instance of this instancer object."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      object_node_id"]
    #[doc = "                 The object node id."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The order of application of translation, rotation and"]
    #[doc = "                 scale."]
    #[doc = ""]
    #[doc = " @param[out]     transforms_array"]
    #[doc = "                 Array of ::HAPI_Transform at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_PartInfo::pointCount - 1. This is the 0th"]
    #[doc = "                 part of the display geo of the instancer object node."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_PartInfo::pointCount - @p start. This is the 0th"]
    #[doc = "                 part of the display geo of the instancer object node."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::pointCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetInstanceTransforms(
        session: *const HAPI_Session,
        object_node_id: HAPI_NodeId,
        rst_order: HAPI_RSTOrder,
        transforms_array: *mut HAPI_Transform,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill an array of ::HAPI_Transform structs with the transforms"]
    #[doc = "         of each instance of this instancer object for a given part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The object node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The order of application of translation, rotation and"]
    #[doc = "                 scale."]
    #[doc = ""]
    #[doc = " @param[out]     transforms_array"]
    #[doc = "                 Array of ::HAPI_Transform at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_PartInfo::pointCount - 1. This is the 0th"]
    #[doc = "                 part of the display geo of the instancer object node."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_PartInfo::pointCount - @p start. This is the 0th"]
    #[doc = "                 part of the display geo of the instancer object node."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::pointCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetInstanceTransformsOnPart(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        rst_order: HAPI_RSTOrder,
        transforms_array: *mut HAPI_Transform,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the transform of an individual object. Note that the object"]
    #[doc = "         nodes have to either be editable or have their transform"]
    #[doc = "         parameters exposed at the asset level. This won't work otherwise."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The object node id."]
    #[doc = ""]
    #[doc = " @param[in]      trans"]
    #[doc = "                 A ::HAPI_TransformEuler that stores the transform."]
    #[doc = ""]
    pub fn HAPI_SetObjectTransform(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        trans: *const HAPI_TransformEuler,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the display geo (SOP) node inside an Object node. If there"]
    #[doc = "         there are multiple display SOP nodes, only the first one is"]
    #[doc = "         returned. If the node is a display SOP itself, even if a network,"]
    #[doc = "         it will return its own geo info. If the node is a SOP but not"]
    #[doc = "         a network and not the display SOP, this function will fail."]
    #[doc = ""]
    #[doc = "         The above implies that you can safely call this function on both"]
    #[doc = "         OBJ and SOP asset nodes and get the same (equivalent) geometry"]
    #[doc = "         display node back. SOP asset nodes will simply return themselves."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      object_node_id"]
    #[doc = "                 The object node id."]
    #[doc = ""]
    #[doc = " @param[out]     geo_info"]
    #[doc = "                 ::HAPI_GeoInfo return value."]
    #[doc = ""]
    pub fn HAPI_GetDisplayGeoInfo(
        session: *const HAPI_Session,
        object_node_id: HAPI_NodeId,
        geo_info: *mut HAPI_GeoInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the geometry info struct (::HAPI_GeoInfo) on a SOP node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     geo_info"]
    #[doc = "                 ::HAPI_GeoInfo return value."]
    #[doc = ""]
    pub fn HAPI_GetGeoInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        geo_info: *mut HAPI_GeoInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get a particular part info struct."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     part_info"]
    #[doc = "                 ::HAPI_PartInfo return value."]
    #[doc = ""]
    pub fn HAPI_GetPartInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        part_info: *mut HAPI_PartInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the array of faces where the nth integer in the array is"]
    #[doc = "         the number of vertices the nth face has."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     face_counts_array"]
    #[doc = "                 An integer array at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_PartInfo::faceCount - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_PartInfo::faceCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::faceCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetFaceCounts(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        face_counts_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get array containing the vertex-point associations where the"]
    #[doc = "         ith element in the array is the point index the ith vertex"]
    #[doc = "         associates with."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     vertex_list_array"]
    #[doc = "                 An integer array at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_PartInfo::vertexCount - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_PartInfo::vertexCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::vertexCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetVertexList(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        vertex_list_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the attribute info struct for the attribute specified by name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      owner"]
    #[doc = "                 Attribute owner."]
    #[doc = ""]
    #[doc = " @param[out]     attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo to be filled. Check"]
    #[doc = "                 ::HAPI_AttributeInfo::exists to see if this attribute"]
    #[doc = "                 exists."]
    #[doc = ""]
    pub fn HAPI_GetAttributeInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        owner: HAPI_AttributeOwner,
        attr_info: *mut HAPI_AttributeInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get list of attribute names by attribute owner. Note that the"]
    #[doc = "         name string handles are only valid until the next time this"]
    #[doc = "         function is called."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      owner"]
    #[doc = "                 The ::HAPI_AttributeOwner enum value specifying the"]
    #[doc = "                 owner of the attribute."]
    #[doc = ""]
    #[doc = " @param[out]     attribute_names_array"]
    #[doc = "                 Array of ints (string handles) to house the"]
    #[doc = "                 attribute names. Should be exactly the size of the"]
    #[doc = "                 appropriate attribute owner type count"]
    #[doc = "                 in ::HAPI_PartInfo."]
    #[doc = ""]
    #[doc = " @param[in]      count"]
    #[doc = "                 Sanity check count. Must be equal to the appropriate"]
    #[doc = "                 attribute owner type count in ::HAPI_PartInfo."]
    #[doc = ""]
    pub fn HAPI_GetAttributeNames(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        owner: HAPI_AttributeOwner,
        attribute_names_array: *mut HAPI_StringHandle,
        count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get attribute integer data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      stride"]
    #[doc = "                 Specifies how many items to skip over for each element."]
    #[doc = "                 With a stride of -1, the stride will be set to"]
    #[doc = "                 @c attr_info->tuple_size. Otherwise, the stride will be"]
    #[doc = "                 set to the maximum of @c attr_info->tuple_size and"]
    #[doc = "                 @c stride."]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        stride: ::std::os::raw::c_int,
        data_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get array attribute integer data."]
    #[doc = "         Each entry in an array attribute can have varying array lengths."]
    #[doc = "         Therefore the array values are returned as a flat array, with"]
    #[doc = "         another sizes array containing the lengths of each array entry."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     data_fixed_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      data_fixed_length"]
    #[doc = "                 Must be <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::totalArrayElements -->"]
    #[doc = ""]
    #[doc = " @param[out]     sizes_fixed_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>sizes_fixed_length</tt> to hold the size of each entry."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count -->"]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      sizes_fixed_length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeIntArrayData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        data_fixed_array: *mut ::std::os::raw::c_int,
        data_fixed_length: ::std::os::raw::c_int,
        sizes_fixed_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        sizes_fixed_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get attribute 64-bit integer data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      stride"]
    #[doc = "                 Specifies how many items to skip over for each element."]
    #[doc = "                 With a stride of -1, the stride will be set to"]
    #[doc = "                 @c attr_info->tuple_size. Otherwise, the stride will be"]
    #[doc = "                 set to the maximum of @c attr_info->tuple_size and"]
    #[doc = "                 @c stride."]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 An 64-bit integer array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeInt64Data(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        stride: ::std::os::raw::c_int,
        data_array: *mut HAPI_Int64,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get array attribute 64-bit integer data."]
    #[doc = "         Each entry in an array attribute can have varying array lengths."]
    #[doc = "         Therefore the array values are returned as a flat array, with"]
    #[doc = "         another sizes array containing the lengths of each array entry."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     data_fixed_array"]
    #[doc = "                 An 64-bit integer array at least the size of"]
    #[doc = "                 <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      data_fixed_length"]
    #[doc = "                 Must be <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::totalArrayElements -->"]
    #[doc = ""]
    #[doc = " @param[out]     sizes_fixed_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>sizes_fixed_length</tt> to hold the size of each entry."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      sizes_fixed_length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeInt64ArrayData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        data_fixed_array: *mut HAPI_Int64,
        data_fixed_length: ::std::os::raw::c_int,
        sizes_fixed_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        sizes_fixed_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get attribute float data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      stride"]
    #[doc = "                 Specifies how many items to skip over for each element."]
    #[doc = "                 With a stride of -1, the stride will be set to"]
    #[doc = "                 @c attr_info->tuple_size. Otherwise, the stride will be"]
    #[doc = "                 set to the maximum of @c attr_info->tuple_size and"]
    #[doc = "                 @c stride."]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 An float array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        stride: ::std::os::raw::c_int,
        data_array: *mut f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get array attribute float data."]
    #[doc = "         Each entry in an array attribute can have varying array lengths."]
    #[doc = "         Therefore the array values are returned as a flat array, with"]
    #[doc = "         another sizes array containing the lengths of each array entry."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     data_fixed_array"]
    #[doc = "                 An float array at least the size of"]
    #[doc = "                 <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      data_fixed_length"]
    #[doc = "                 Must be <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::totalArrayElements -->"]
    #[doc = ""]
    #[doc = " @param[out]     sizes_fixed_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                <tt>sizes_fixed_length</tt> to hold the size of each entry."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      sizes_fixed_length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeFloatArrayData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        data_fixed_array: *mut f32,
        data_fixed_length: ::std::os::raw::c_int,
        sizes_fixed_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        sizes_fixed_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get 64-bit attribute float data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      stride"]
    #[doc = "                 Specifies how many items to skip over for each element."]
    #[doc = "                 With a stride of -1, the stride will be set to"]
    #[doc = "                 @c attr_info->tuple_size. Otherwise, the stride will be"]
    #[doc = "                 set to the maximum of @c attr_info->tuple_size and"]
    #[doc = "                 @c stride."]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 An 64-bit float array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeFloat64Data(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        stride: ::std::os::raw::c_int,
        data_array: *mut f64,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get array attribute 64-bit float data."]
    #[doc = "         Each entry in an array attribute can have varying array lengths."]
    #[doc = "         Therefore the array values are returned as a flat array, with"]
    #[doc = "         another sizes array containing the lengths of each array entry."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for the."]
    #[doc = "                 totalArrayElements. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     data_fixed_array"]
    #[doc = "                 An 64-bit float array at least the size of"]
    #[doc = "                 <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      data_fixed_length"]
    #[doc = "                 Must be <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::totalArrayElements -->"]
    #[doc = ""]
    #[doc = " @param[out]     sizes_fixed_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>sizes_fixed_length</tt> to hold the size of each entry."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      sizes_fixed_length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeFloat64ArrayData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        data_fixed_array: *mut f64,
        data_fixed_length: ::std::os::raw::c_int,
        sizes_fixed_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        sizes_fixed_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get attribute string data. Note that the string handles"]
    #[doc = "         returned are only valid until the next time this function"]
    #[doc = "         is called."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 An ::HAPI_StringHandle array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeStringData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        data_array: *mut HAPI_StringHandle,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get array attribute string data."]
    #[doc = "         Each entry in an array attribute can have varying array lengths."]
    #[doc = "         Therefore the array values are returned as a flat array, with"]
    #[doc = "         another sizes array containing the lengths of each array entry."]
    #[doc = "         Note that the string handles returned are only valid until"]
    #[doc = "         the next time this function is called."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for the."]
    #[doc = "                 totalArrayElements. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[out]     data_fixed_array"]
    #[doc = "                 An ::HAPI_StringHandle array at least the size of"]
    #[doc = "                 <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      data_fixed_length"]
    #[doc = "                 Must be <tt>::HAPI_AttributeInfo::totalArrayElements</tt>."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::totalArrayElements -->"]
    #[doc = ""]
    #[doc = " @param[out]     sizes_fixed_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>sizes_fixed_length</tt> to hold the size of each entry."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      sizes_fixed_length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 Note, if 0 is passed for length, the function will just"]
    #[doc = "                 do nothing and return ::HAPI_RESULT_SUCCESS."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_GetAttributeStringArrayData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *mut HAPI_AttributeInfo,
        data_fixed_array: *mut HAPI_StringHandle,
        data_fixed_length: ::std::os::raw::c_int,
        sizes_fixed_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        sizes_fixed_length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get group names for an entire geo. Please note that this"]
    #[doc = "         function is NOT per-part, but it is per-geo. The companion"]
    #[doc = "         function ::HAPI_GetGroupMembership() IS per-part. Also keep"]
    #[doc = "         in mind that the name string handles are only"]
    #[doc = "         valid until the next time this function is called."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[out]     group_names_array"]
    #[doc = "                 The array of names to be filled. Should be the size"]
    #[doc = "                 given by ::HAPI_GeoInfo_GetGroupCountByType() with"]
    #[doc = "                 @p group_type and the ::HAPI_GeoInfo of @p geo_id."]
    #[doc = "                 @note These string handles are only valid until the"]
    #[doc = "                 next call to ::HAPI_GetGroupNames()."]
    #[doc = ""]
    #[doc = " @param[in]      group_count"]
    #[doc = "                 Sanity check. Should be less than or equal to the size"]
    #[doc = "                 of @p group_names."]
    #[doc = ""]
    pub fn HAPI_GetGroupNames(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        group_type: HAPI_GroupType,
        group_names_array: *mut HAPI_StringHandle,
        group_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get group membership."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[in]      group_name"]
    #[doc = "                 The group name."]
    #[doc = ""]
    #[doc = " @param[out]     membership_array_all_equal"]
    #[doc = "                 (optional) Quick way to determine if all items are in"]
    #[doc = "                 the given group or all items our not in the group."]
    #[doc = "                 You can just pass NULL here if not interested."]
    #[doc = ""]
    #[doc = " @param[out]     membership_array"]
    #[doc = "                 Array of ints that represent the membership of this"]
    #[doc = "                 group. Should be the size given by"]
    #[doc = "                 ::HAPI_PartInfo_GetElementCountByGroupType() with"]
    #[doc = "                 @p group_type and the ::HAPI_PartInfo of @p part_id."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 Start offset into the membership array. Must be"]
    #[doc = "                 less than ::HAPI_PartInfo_GetElementCountByGroupType()."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Should be less than or equal to the size"]
    #[doc = "                 of @p membership_array."]
    #[doc = "\t\t    <!-- source ::HAPI_PartInfo_GetElementCountByGroupType -->"]
    #[doc = ""]
    pub fn HAPI_GetGroupMembership(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        group_type: HAPI_GroupType,
        group_name: *const ::std::os::raw::c_char,
        membership_array_all_equal: *mut HAPI_Bool,
        membership_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get group counts for a specific packed instanced part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id. (should be a packed primitive)"]
    #[doc = ""]
    #[doc = " @param[out]     pointGroupCount"]
    #[doc = "                 Number of point groups on the packed instance part."]
    #[doc = "                 Will be set to -1 if the part is not a valid packed part."]
    #[doc = ""]
    #[doc = " @param[out]     primitiveGroupCount"]
    #[doc = "                 Number of primitive groups on the instanced part."]
    #[doc = "                 Will be set to -1 if the part is not a valid instancer"]
    #[doc = ""]
    pub fn HAPI_GetGroupCountOnPackedInstancePart(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        pointGroupCount: *mut ::std::os::raw::c_int,
        primitiveGroupCount: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the group names for a packed instance part"]
    #[doc = "         This functions allows you to get the group name for a specific"]
    #[doc = "         packed primitive part."]
    #[doc = "         Keep in mind that the name string handles are only"]
    #[doc = "         valid until the next time this function is called."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id. (should be a packed primitive)"]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[out]     group_names_array"]
    #[doc = "                 The array of names to be filled. Should be the size"]
    #[doc = "                 given by ::HAPI_GetGroupCountOnInstancedPart() with"]
    #[doc = "                 @p group_type and the ::HAPI_PartInfo of @p part_id."]
    #[doc = "                 @note These string handles are only valid until the"]
    #[doc = "                 next call to ::HAPI_GetGroupNamesOnPackedInstancePart()."]
    #[doc = ""]
    #[doc = " @param[in]      group_count"]
    #[doc = "                 Sanity check. Should be less than or equal to the size"]
    #[doc = "                 of @p group_names."]
    #[doc = ""]
    pub fn HAPI_GetGroupNamesOnPackedInstancePart(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        group_type: HAPI_GroupType,
        group_names_array: *mut HAPI_StringHandle,
        group_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get group membership for a packed instance part"]
    #[doc = "         This functions allows you to get the group membership for a specific"]
    #[doc = "         packed primitive part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id. (should be a packed primitive)"]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[in]      group_name"]
    #[doc = "                 The group name."]
    #[doc = ""]
    #[doc = " @param[out]     membership_array_all_equal"]
    #[doc = "                 (optional) Quick way to determine if all items are in"]
    #[doc = "                 the given group or all items our not in the group."]
    #[doc = "                 You can just pass NULL here if not interested."]
    #[doc = ""]
    #[doc = " @param[out]     membership_array"]
    #[doc = "                 Array of ints that represent the membership of this"]
    #[doc = "                 group. Should be the size given by"]
    #[doc = "                 ::HAPI_PartInfo_GetElementCountByGroupType() with"]
    #[doc = "                 @p group_type and the ::HAPI_PartInfo of @p part_id."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 Start offset into the membership array. Must be"]
    #[doc = "                 less than ::HAPI_PartInfo_GetElementCountByGroupType()."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Should be less than or equal to the size"]
    #[doc = "                 of @p membership_array."]
    #[doc = "\t\t    <!-- source ::HAPI_PartInfo_GetElementCountByGroupType -->"]
    #[doc = ""]
    pub fn HAPI_GetGroupMembershipOnPackedInstancePart(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        group_type: HAPI_GroupType,
        group_name: *const ::std::os::raw::c_char,
        membership_array_all_equal: *mut HAPI_Bool,
        membership_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the part ids that this instancer part is instancing."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The instancer part id."]
    #[doc = ""]
    #[doc = " @param[out]     instanced_parts_array"]
    #[doc = "                 Array of ::HAPI_PartId's to instance."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 Should be less than @p part_id's"]
    #[doc = "                 ::HAPI_PartInfo::instancedPartCount but more than or"]
    #[doc = "                 equal to 0."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Should be less than @p part_id's"]
    #[doc = "                 ::HAPI_PartInfo::instancedPartCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::instancedPartCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetInstancedPartIds(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        instanced_parts_array: *mut HAPI_PartId,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the instancer part's list of transforms on which to"]
    #[doc = "         instance the instanced parts you got from"]
    #[doc = "         ::HAPI_GetInstancedPartIds()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The instancer part id."]
    #[doc = ""]
    #[doc = " @param[in]      rst_order"]
    #[doc = "                 The order of application of translation, rotation and"]
    #[doc = "                 scale."]
    #[doc = ""]
    #[doc = " @param[out]     transforms_array"]
    #[doc = "                 Array of ::HAPI_PartId's to instance."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 Should be less than @p part_id's"]
    #[doc = "                 ::HAPI_PartInfo::instanceCount but more than or"]
    #[doc = "                 equal to 0."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Should be less than @p part_id's"]
    #[doc = "                 ::HAPI_PartInfo::instanceCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::instanceCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetInstancerPartTransforms(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        rst_order: HAPI_RSTOrder,
        transforms_array: *mut HAPI_Transform,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the main part info struct (::HAPI_PartInfo)."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      part_info"]
    #[doc = "                 ::HAPI_PartInfo value that describes the input"]
    #[doc = "                 geometry."]
    #[doc = ""]
    pub fn HAPI_SetPartInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        part_info: *const HAPI_PartInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the array of faces where the nth integer in the array is"]
    #[doc = "         the number of vertices the nth face has."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      face_counts_array"]
    #[doc = "                 An integer array at least the size of @p length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_PartInfo::faceCount - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_PartInfo::faceCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::faceCount - start -->"]
    #[doc = ""]
    pub fn HAPI_SetFaceCounts(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        face_counts_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set array containing the vertex-point associations where the"]
    #[doc = "         ith element in the array is the point index the ith vertex"]
    #[doc = "         associates with."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      vertex_list_array"]
    #[doc = "                 An integer array at least the size of length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_PartInfo::vertexCount - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_PartInfo::vertexCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::vertexCount - start -->"]
    #[doc = ""]
    pub fn HAPI_SetVertexList(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        vertex_list_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Add an attribute."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo stores attribute properties."]
    #[doc = ""]
    pub fn HAPI_AddAttribute(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Delete an attribute from an input geo"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo stores attribute properties."]
    #[doc = ""]
    pub fn HAPI_DeleteAttribute(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set attribute integer data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      data_array"]
    #[doc = "                 An integer array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_SetAttributeIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
        data_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set 64-bit attribute integer data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      data_array"]
    #[doc = "                 An 64-bit integer array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_SetAttributeInt64Data(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
        data_array: *const HAPI_Int64,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set attribute float data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      data_array"]
    #[doc = "                 An float array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_SetAttributeFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
        data_array: *const f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set 64-bit attribute float data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      data_array"]
    #[doc = "                 An 64-bit float array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_SetAttributeFloat64Data(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
        data_array: *const f64,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set attribute string data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 Attribute name."]
    #[doc = ""]
    #[doc = " @param[in]      attr_info"]
    #[doc = "                 ::HAPI_AttributeInfo used as input for what tuple size."]
    #[doc = "                 you want. Also contains some sanity checks like"]
    #[doc = "                 data type. Generally should be the same struct"]
    #[doc = "                 returned by ::HAPI_GetAttributeInfo()."]
    #[doc = ""]
    #[doc = " @param[in]      data_array"]
    #[doc = "                 An ::HAPI_StringHandle array at least the size of"]
    #[doc = "                 <tt>length * ::HAPI_AttributeInfo::tupleSize</tt>."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 First index of range. Must be at least 0 and at"]
    #[doc = "                 most ::HAPI_AttributeInfo::count - 1."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Must be at least 0 and at most"]
    #[doc = "                 ::HAPI_AttributeInfo::count - @p start."]
    #[doc = "                 <!-- source ::HAPI_AttributeInfo::count - start -->"]
    #[doc = ""]
    pub fn HAPI_SetAttributeStringData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        attr_info: *const HAPI_AttributeInfo,
        data_array: *mut *const ::std::os::raw::c_char,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Add a group to the input geo with the given type and name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[in]      group_name"]
    #[doc = "                 Name of new group to be added."]
    #[doc = ""]
    pub fn HAPI_AddGroup(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        group_type: HAPI_GroupType,
        group_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Remove a group from the input geo with the given type and name."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[in]      group_name"]
    #[doc = "                 Name of the group to be removed"]
    #[doc = ""]
    pub fn HAPI_DeleteGroup(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        group_type: HAPI_GroupType,
        group_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set group membership."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently not used. Just pass 0."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      group_type"]
    #[doc = "                 The group type."]
    #[doc = ""]
    #[doc = " @param[in]      group_name"]
    #[doc = "                 The group name."]
    #[doc = ""]
    #[doc = " @param[in]      membership_array"]
    #[doc = "                 Array of ints that represent the membership of this"]
    #[doc = "                 group. Should be the size given by"]
    #[doc = "                 ::HAPI_PartInfo_GetElementCountByGroupType() with"]
    #[doc = "                 @p group_type and the ::HAPI_PartInfo of @p part_id."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 Start offset into the membership array. Must be"]
    #[doc = "                 less than ::HAPI_PartInfo_GetElementCountByGroupType()."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Should be less than or equal to the size"]
    #[doc = "                 of @p membership_array."]
    #[doc = "\t\t    <!-- source ::HAPI_PartInfo_GetElementCountByGroupType -->"]
    #[doc = ""]
    pub fn HAPI_SetGroupMembership(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        group_type: HAPI_GroupType,
        group_name: *const ::std::os::raw::c_char,
        membership_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Commit the current input geometry to the cook engine. Nodes"]
    #[doc = "         that use this geometry node will re-cook using the input"]
    #[doc = "         geometry given through the geometry setter API calls."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    pub fn HAPI_CommitGeo(session: *const HAPI_Session, node_id: HAPI_NodeId) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Remove all changes that have been committed to this"]
    #[doc = "         geometry. If this is an intermediate result node (Edit SOP), all"]
    #[doc = "         deltas will be removed. If it's any other type of node, the node"]
    #[doc = "         will be unlocked if it is locked."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The SOP node id."]
    #[doc = ""]
    pub fn HAPI_RevertGeo(session: *const HAPI_Session, node_id: HAPI_NodeId) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get material ids by face/primitive. The material ids returned"]
    #[doc = "         will be valid as long as the asset is alive. You should query"]
    #[doc = "         this list after every cook to see if the material assignments"]
    #[doc = "         have changed. You should also query each material individually"]
    #[doc = "         using ::HAPI_GetMaterialInfo() to see if it is dirty and needs"]
    #[doc = "         to be re-imported."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      geometry_node_id"]
    #[doc = "                 The geometry node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     are_all_the_same"]
    #[doc = "                 (optional) If true, all faces on this part have the"]
    #[doc = "                 same material assignment. You can pass NULL here."]
    #[doc = ""]
    #[doc = " @param[out]     material_ids_array"]
    #[doc = "                 An array of ::HAPI_NodeId at least the size of"]
    #[doc = "                 @p length and at most the size of"]
    #[doc = "                 ::HAPI_PartInfo::faceCount."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The starting index into the list of faces from which"]
    #[doc = "                 you wish to get the material ids from. Note that"]
    #[doc = "                 this should be less than ::HAPI_PartInfo::faceCount."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of material ids you wish to get. Note that"]
    #[doc = "                 this should be at most:"]
    #[doc = "                 ::HAPI_PartInfo::faceCount - @p start."]
    #[doc = "                 <!-- source ::HAPI_PartInfo::faceCount - start -->"]
    #[doc = ""]
    pub fn HAPI_GetMaterialNodeIdsOnFaces(
        session: *const HAPI_Session,
        geometry_node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        are_all_the_same: *mut HAPI_Bool,
        material_ids_array: *mut HAPI_NodeId,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the material info."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[out]     material_info"]
    #[doc = "                 The returned material info."]
    #[doc = ""]
    pub fn HAPI_GetMaterialInfo(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        material_info: *mut HAPI_MaterialInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Render a single texture from a COP to an image for"]
    #[doc = "         later extraction."]
    #[doc = ""]
    #[doc = "         Note that you must call this first for any of the other material"]
    #[doc = "         APIs to work."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      cop_node_id"]
    #[doc = "                 The COP node id."]
    #[doc = ""]
    pub fn HAPI_RenderCOPToImage(
        session: *const HAPI_Session,
        cop_node_id: HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Render only a single texture to an image for later extraction."]
    #[doc = "         An example use of this method might be to render the diffuse,"]
    #[doc = "         normal, and bump texture maps of a material to individual"]
    #[doc = "         texture files for use within the client application."]
    #[doc = ""]
    #[doc = "         Note that you must call this first for any of the other material"]
    #[doc = "         APIs to work."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 This is the index in the parameter list of the"]
    #[doc = "                 material_id's node of the parameter containing the"]
    #[doc = "                 texture map file path."]
    #[doc = ""]
    pub fn HAPI_RenderTextureToImage(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get information about the image that was just rendered, like"]
    #[doc = "         resolution and default file format. This information will be"]
    #[doc = "         used when extracting planes to an image."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[out]     image_info"]
    #[doc = "                 The struct containing the image information."]
    #[doc = ""]
    pub fn HAPI_GetImageInfo(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_info: *mut HAPI_ImageInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set image information like resolution and file format."]
    #[doc = "         This information will be used when extracting planes to"]
    #[doc = "         an image."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = "         You should also first call ::HAPI_GetImageInfo() to get the"]
    #[doc = "         current Image Info and change only the properties"]
    #[doc = "         you don't like."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[in]      image_info"]
    #[doc = "                 The struct containing the new image information."]
    #[doc = ""]
    pub fn HAPI_SetImageInfo(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_info: *const HAPI_ImageInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the number of image planes for the just rendered image."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[out]     image_plane_count"]
    #[doc = "                 The number of image planes."]
    #[doc = ""]
    pub fn HAPI_GetImagePlaneCount(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_plane_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the names of the image planes of the just rendered image."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = "         You should also call ::HAPI_GetImagePlaneCount() first to get"]
    #[doc = "         the total number of image planes so you know how large the"]
    #[doc = "         image_planes string handle array should be."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[out]     image_planes_array"]
    #[doc = "                 The image plane names."]
    #[doc = ""]
    #[doc = " @param[in]      image_plane_count"]
    #[doc = "                 The number of image planes to get names for. This"]
    #[doc = "                 must be less than or equal to the count returned"]
    #[doc = "                 by ::HAPI_GetImagePlaneCount()."]
    #[doc = "                 <!-- source ::HAPI_GetImagePlaneCount -->"]
    #[doc = ""]
    pub fn HAPI_GetImagePlanes(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_planes_array: *mut HAPI_StringHandle,
        image_plane_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Extract a rendered image to a file."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[in]      image_file_format_name"]
    #[doc = "                 The image file format name you wish the image to be"]
    #[doc = "                 extracted as. You can leave this parameter NULL to"]
    #[doc = "                 get the image in the original format if it comes from"]
    #[doc = "                 another texture file or in the default HAPI format,"]
    #[doc = "                 which is ::HAPI_DEFAULT_IMAGE_FORMAT_NAME, if the image"]
    #[doc = "                 is generated."]
    #[doc = ""]
    #[doc = "                 You can get some of the very common standard image"]
    #[doc = "                 file format names from HAPI_Common.h under the"]
    #[doc = "                 \"Defines\" section."]
    #[doc = ""]
    #[doc = "                 You can also get a list of all supported file formats"]
    #[doc = "                 (and the exact names this parameter expects)"]
    #[doc = "                 by using ::HAPI_GetSupportedImageFileFormats(). This"]
    #[doc = "                 list will include custom file formats you created via"]
    #[doc = "                 custom DSOs (see HDK docs about IMG_Format). You will"]
    #[doc = "                 get back a list of ::HAPI_ImageFileFormat. This"]
    #[doc = "                 parameter expects the ::HAPI_ImageFileFormat::nameSH"]
    #[doc = "                 of a given image file format."]
    #[doc = ""]
    #[doc = " @param[in]      image_planes"]
    #[doc = "                 The image planes you wish to extract into the file."]
    #[doc = "                 Multiple image planes should be separated by spaces."]
    #[doc = ""]
    #[doc = " @param[in]      destination_folder_path"]
    #[doc = "                 The folder where the image file should be created."]
    #[doc = ""]
    #[doc = " @param[in]      destination_file_name"]
    #[doc = "                 Optional parameter to overwrite the name of the"]
    #[doc = "                 extracted texture file. This should NOT include"]
    #[doc = "                 the extension as the file type will be decided"]
    #[doc = "                 by the ::HAPI_ImageInfo you can set using"]
    #[doc = "                 ::HAPI_SetImageInfo(). You still have to use"]
    #[doc = "                 destination_file_path to get the final file path."]
    #[doc = ""]
    #[doc = "                 Pass in NULL to have the file name be automatically"]
    #[doc = "                 generated from the name of the material SHOP node,"]
    #[doc = "                 the name of the texture map parameter if the"]
    #[doc = "                 image was rendered from a texture, and the image"]
    #[doc = "                 plane names specified."]
    #[doc = ""]
    #[doc = " @param[out]     destination_file_path"]
    #[doc = "                 The full path string handle, including the"]
    #[doc = "                 destination_folder_path and the texture file name,"]
    #[doc = "                 to the extracted file. Note that this string handle"]
    #[doc = "                 will only be valid until the next call to"]
    #[doc = "                 this function."]
    #[doc = ""]
    pub fn HAPI_ExtractImageToFile(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_file_format_name: *const ::std::os::raw::c_char,
        image_planes: *const ::std::os::raw::c_char,
        destination_folder_path: *const ::std::os::raw::c_char,
        destination_file_name: *const ::std::os::raw::c_char,
        destination_file_path: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the file name that this image would be saved to"]
    #[doc = ""]
    #[doc = "         Check to see what file path HAPI_ExtractImageToFile would have"]
    #[doc = "         saved to given the same parms. Perhaps you might wish to see"]
    #[doc = "         if it already exists before extracting."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[in]      image_file_format_name"]
    #[doc = "                 The image file format name you wish the image to be"]
    #[doc = "                 extracted as. See HAPI_ExtractImageToFile for more information."]
    #[doc = ""]
    #[doc = " @param[in]      image_planes"]
    #[doc = "                 The image planes you wish to extract into the file."]
    #[doc = "                 Multiple image planes should be separated by spaces."]
    #[doc = ""]
    #[doc = " @param[in]      destination_folder_path"]
    #[doc = "                 The folder where the image file sould be created."]
    #[doc = ""]
    #[doc = " @param[in]      destination_file_name"]
    #[doc = "                 Optional parameter to overwrite the name of the"]
    #[doc = "                 extracted texture file. See HAPI_ExtractImageToFile for more information."]
    #[doc = ""]
    #[doc = " @param[in]      texture_parm_id"]
    #[doc = "                 The index in the parameter list of the material node."]
    #[doc = "                 of the parameter containing the texture map file path"]
    #[doc = ""]
    #[doc = " @param[out]     destination_file_path"]
    #[doc = "                 The full path string handle, including the"]
    #[doc = "                 destination_folder_path and the texture file name,"]
    #[doc = "                 to the extracted file. Note that this string handle"]
    #[doc = "                 will only be valid until the next call to"]
    #[doc = "                 this function."]
    #[doc = ""]
    pub fn HAPI_GetImageFilePath(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_file_format_name: *const ::std::os::raw::c_char,
        image_planes: *const ::std::os::raw::c_char,
        destination_folder_path: *const ::std::os::raw::c_char,
        destination_file_name: *const ::std::os::raw::c_char,
        texture_parm_id: HAPI_ParmId,
        destination_file_path: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Extract a rendered image to memory."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = "         Also note that this function will do all the work of"]
    #[doc = "         extracting and compositing the image into a memory buffer"]
    #[doc = "         but will not return to you that buffer, only its size. Use"]
    #[doc = "         the returned size to allocated a sufficiently large buffer"]
    #[doc = "         and call ::HAPI_GetImageMemoryBuffer() to fill your buffer"]
    #[doc = "         with the just extracted image."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[in]      image_file_format_name"]
    #[doc = "                 The image file format name you wish the image to be"]
    #[doc = "                 extracted as. You can leave this parameter NULL to"]
    #[doc = "                 get the image in the original format if it comes from"]
    #[doc = "                 another texture file or in the default HAPI format,"]
    #[doc = "                 which is ::HAPI_DEFAULT_IMAGE_FORMAT_NAME, if the image"]
    #[doc = "                 is generated."]
    #[doc = ""]
    #[doc = "                 You can get some of the very common standard image"]
    #[doc = "                 file format names from HAPI_Common.h under the"]
    #[doc = "                 \"Defines\" section."]
    #[doc = ""]
    #[doc = "                 You can also get a list of all supported file formats"]
    #[doc = "                 (and the exact names this parameter expects)"]
    #[doc = "                 by using ::HAPI_GetSupportedImageFileFormats(). This"]
    #[doc = "                 list will include custom file formats you created via"]
    #[doc = "                 custom DSOs (see HDK docs about IMG_Format). You will"]
    #[doc = "                 get back a list of ::HAPI_ImageFileFormat. This"]
    #[doc = "                 parameter expects the ::HAPI_ImageFileFormat::nameSH"]
    #[doc = "                 of a given image file format."]
    #[doc = ""]
    #[doc = " @param[in]      image_planes"]
    #[doc = "                 The image planes you wish to extract into the file."]
    #[doc = "                 Multiple image planes should be separated by spaces."]
    #[doc = ""]
    #[doc = " @param[out]     buffer_size"]
    #[doc = "                 The extraction will be done to an internal buffer"]
    #[doc = "                 who's size you get via this parameter. Use the"]
    #[doc = "                 returned buffer_size when calling"]
    #[doc = "                 ::HAPI_GetImageMemoryBuffer() to get the image"]
    #[doc = "                 buffer you just extracted."]
    #[doc = ""]
    pub fn HAPI_ExtractImageToMemory(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        image_file_format_name: *const ::std::os::raw::c_char,
        image_planes: *const ::std::os::raw::c_char,
        buffer_size: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Fill your allocated buffer with the just extracted"]
    #[doc = "         image buffer."]
    #[doc = ""]
    #[doc = "         Note that you must call ::HAPI_RenderTextureToImage() first for"]
    #[doc = "         this method call to make sense."]
    #[doc = ""]
    #[doc = "         Also note that you must call ::HAPI_ExtractImageToMemory()"]
    #[doc = "         first in order to perform the extraction and get the"]
    #[doc = "         extracted image buffer size that you need to know how much"]
    #[doc = "         memory to allocated to fit your extracted image."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      material_node_id"]
    #[doc = "                 The material node id."]
    #[doc = ""]
    #[doc = " @param[out]     buffer"]
    #[doc = "                 The buffer passed in here will be filled with the"]
    #[doc = "                 image buffer created during the call to"]
    #[doc = "                 ::HAPI_ExtractImageToMemory()."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 Sanity check. This size should be the same as the"]
    #[doc = "                 size allocated for the buffer passed in and should"]
    #[doc = "                 be at least as large as the buffer_size returned by"]
    #[doc = "                 the call to ::HAPI_ExtractImageToMemory()."]
    #[doc = "                 <!-- source ::HAPI_ExtractImageToMemory -->"]
    #[doc = ""]
    pub fn HAPI_GetImageMemoryBuffer(
        session: *const HAPI_Session,
        material_node_id: HAPI_NodeId,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the number of supported texture file formats."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     file_format_count"]
    #[doc = "                 The number of supported texture file formats."]
    #[doc = ""]
    pub fn HAPI_GetSupportedImageFileFormatCount(
        session: *const HAPI_Session,
        file_format_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get a list of support image file formats - their names,"]
    #[doc = "         descriptions and a list of recognized extensions."]
    #[doc = ""]
    #[doc = "         Note that you MUST call"]
    #[doc = "         ::HAPI_GetSupportedImageFileFormatCount()"]
    #[doc = "         before calling this function for the first time."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     formats_array"]
    #[doc = "                 The list of ::HAPI_ImageFileFormat structs to"]
    #[doc = "                 be filled."]
    #[doc = ""]
    #[doc = " @param[in]      file_format_count"]
    #[doc = "                 The number of supported texture file formats. This"]
    #[doc = "                 should be at least as large as the count returned"]
    #[doc = "                 by ::HAPI_GetSupportedImageFileFormatCount()."]
    #[doc = "                 <!-- source ::HAPI_GetSupportedImageFileFormatCount -->"]
    #[doc = ""]
    pub fn HAPI_GetSupportedImageFileFormats(
        session: *const HAPI_Session,
        formats_array: *mut HAPI_ImageFileFormat,
        file_format_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set an animation curve on a parameter of an exposed node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The exposed node id."]
    #[doc = ""]
    #[doc = " @param[in]      parm_id"]
    #[doc = "                 The id of an exposed parameter within the node."]
    #[doc = " @param[in]      parm_index"]
    #[doc = "                 The index of the parameter, if it is for example"]
    #[doc = "                 a 3 tuple"]
    #[doc = ""]
    #[doc = " @param[in]      curve_keyframes_array"]
    #[doc = "                 An array of ::HAPI_Keyframe structs that describes"]
    #[doc = "                 the keys on this curve."]
    #[doc = ""]
    #[doc = " @param[in]      keyframe_count"]
    #[doc = "                 The number of keys on the curve."]
    #[doc = ""]
    pub fn HAPI_SetAnimCurve(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        parm_id: HAPI_ParmId,
        parm_index: ::std::os::raw::c_int,
        curve_keyframes_array: *const HAPI_Keyframe,
        keyframe_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  A specialized convenience function to set the T,R,S values"]
    #[doc = "         on an exposed node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The exposed node id."]
    #[doc = ""]
    #[doc = " @param[in]      trans_comp"]
    #[doc = "                 A value of ::HAPI_TransformComponent that"]
    #[doc = "                 identifies the particular component of the"]
    #[doc = "                 transform to attach the curve to, for example"]
    #[doc = "                 ::HAPI_TRANSFORM_TX."]
    #[doc = ""]
    #[doc = " @param[in]      curve_keyframes_array"]
    #[doc = "                 An array of ::HAPI_Keyframe structs that describes"]
    #[doc = "                 the keys on this curve."]
    #[doc = ""]
    #[doc = " @param[in]      keyframe_count"]
    #[doc = "                 The number of keys on the curve."]
    #[doc = ""]
    pub fn HAPI_SetTransformAnimCurve(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        trans_comp: HAPI_TransformComponent,
        curve_keyframes_array: *const HAPI_Keyframe,
        keyframe_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Resets the simulation cache of the asset.  This is very useful"]
    #[doc = "         for assets that use dynamics, to be called after some"]
    #[doc = "         setup has changed for the asset - for example, asset inputs"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The asset node id."]
    #[doc = ""]
    pub fn HAPI_ResetSimulation(session: *const HAPI_Session, node_id: HAPI_NodeId) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve any meta-data about the volume primitive, including"]
    #[doc = "         its transform, location, scale, taper, resolution."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     volume_info"]
    #[doc = "                 The meta-data associated with the volume on the"]
    #[doc = "                 part specified by the previous parameters."]
    #[doc = ""]
    pub fn HAPI_GetVolumeInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        volume_info: *mut HAPI_VolumeInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Iterate through a volume based on 8x8x8 sections of the volume"]
    #[doc = "         Start iterating through the value of the volume at part_id."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     tile"]
    #[doc = "                 The tile info referring to the first tile in the"]
    #[doc = "                 volume at part_id."]
    #[doc = ""]
    pub fn HAPI_GetFirstVolumeTile(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        tile: *mut HAPI_VolumeTileInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Iterate through a volume based on 8x8x8 sections of the volume"]
    #[doc = "         Continue iterating through the value of the volume at part_id."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     tile"]
    #[doc = "                 The tile info referring to the next tile in the"]
    #[doc = "                 set of tiles associated with the volume at this part."]
    #[doc = ""]
    pub fn HAPI_GetNextVolumeTile(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        tile: *mut HAPI_VolumeTileInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve floating point values of the voxel at a specific"]
    #[doc = "         index. Note that you must call ::HAPI_GetVolumeInfo() prior"]
    #[doc = "         to this call."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      x_index"]
    #[doc = "                 The x index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      y_index"]
    #[doc = "                 The y index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      z_index"]
    #[doc = "                 The z index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 The values of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      value_count"]
    #[doc = "                 Should be equal to the volume's"]
    #[doc = "                 ::HAPI_VolumeInfo::tupleSize."]
    #[doc = "                 <!-- source ::HAPI_VolumeInfo::tupleSize -->"]
    #[doc = ""]
    pub fn HAPI_GetVolumeVoxelFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        x_index: ::std::os::raw::c_int,
        y_index: ::std::os::raw::c_int,
        z_index: ::std::os::raw::c_int,
        values_array: *mut f32,
        value_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve floating point values of the voxels pointed to"]
    #[doc = "         by a tile. Note that a tile may extend beyond the limits"]
    #[doc = "         of the volume so not all values in the given buffer will"]
    #[doc = "         be written to. Voxels outside the volume will be initialized"]
    #[doc = "         to the given fill value."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      fill_value"]
    #[doc = "                 Value that will be used to fill the @p values_array."]
    #[doc = "                 This is useful so that you can see what values"]
    #[doc = "                 have actually been written to."]
    #[doc = ""]
    #[doc = " @param[in]      tile"]
    #[doc = "                 The tile to retrieve."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 The values of the tile."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length should be ( 8 ^ 3 ) * tupleSize."]
    #[doc = ""]
    pub fn HAPI_GetVolumeTileFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        fill_value: f32,
        tile: *const HAPI_VolumeTileInfo,
        values_array: *mut f32,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve integer point values of the voxel at a specific"]
    #[doc = "         index. Note that you must call ::HAPI_GetVolumeInfo() prior"]
    #[doc = "         to this call."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      x_index"]
    #[doc = "                 The x index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      y_index"]
    #[doc = "                 The y index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      z_index"]
    #[doc = "                 The z index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 The values of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      value_count"]
    #[doc = "                 Should be equal to the volume's"]
    #[doc = "                 ::HAPI_VolumeInfo::tupleSize."]
    #[doc = "                 <!-- source ::HAPI_VolumeInfo::tupleSize -->"]
    #[doc = ""]
    pub fn HAPI_GetVolumeVoxelIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        x_index: ::std::os::raw::c_int,
        y_index: ::std::os::raw::c_int,
        z_index: ::std::os::raw::c_int,
        values_array: *mut ::std::os::raw::c_int,
        value_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve integer point values of the voxels pointed to"]
    #[doc = "         by a tile. Note that a tile may extend beyond the limits"]
    #[doc = "         of the volume so not all values in the given buffer will"]
    #[doc = "         be written to. Voxels outside the volume will be initialized"]
    #[doc = "         to the given fill value."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      fill_value"]
    #[doc = "                 Value that will be used to fill the @p values_array."]
    #[doc = "                 This is useful so that you can see what values"]
    #[doc = "                 have actually been written to."]
    #[doc = ""]
    #[doc = " @param[in]      tile"]
    #[doc = "                 The tile to retrieve."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 The values of the tile."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length should be ( 8 ^ 3 ) * tupleSize."]
    #[doc = ""]
    pub fn HAPI_GetVolumeTileIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        fill_value: ::std::os::raw::c_int,
        tile: *const HAPI_VolumeTileInfo,
        values_array: *mut ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the height field data for a terrain volume as a flattened"]
    #[doc = "         2D array of float heights. Should call ::HAPI_GetVolumeInfo()"]
    #[doc = "         first to make sure the volume info is initialized."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     values_array"]
    #[doc = "                 Heightfield flattened array. Should be at least the size of"]
    #[doc = "                 @p start + @p length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The start at least 0 and at most"]
    #[doc = "                 ( ::HAPI_VolumeInfo::xLength * ::HAPI_VolumeInfo::yLength )"]
    #[doc = "                 - @p length."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length should be at least 1 or at most"]
    #[doc = "                 ( ::HAPI_VolumeInfo::xLength * ::HAPI_VolumeInfo::yLength )"]
    #[doc = "                 - @p start."]
    #[doc = ""]
    pub fn HAPI_GetHeightFieldData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        values_array: *mut f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the volume info of a geo on a geo input."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      volume_info"]
    #[doc = "                 All volume information that can be specified per"]
    #[doc = "                 volume. This includes the position, orientation, scale,"]
    #[doc = "                 data format, tuple size, and taper. The tile size is"]
    #[doc = "                 always 8x8x8."]
    #[doc = ""]
    pub fn HAPI_SetVolumeInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        volume_info: *const HAPI_VolumeInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the values of a float tile: this is an 8x8x8 subsection of"]
    #[doc = "         the volume."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      tile"]
    #[doc = "                 The tile that the volume will be input into."]
    #[doc = ""]
    #[doc = " @param[in]      values_array"]
    #[doc = "                 The values of the individual voxel tiles in the"]
    #[doc = "                 volume. The length of this array should"]
    #[doc = "                 be ( 8 ^ 3 ) * tupleSize."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length should be ( 8 ^ 3 ) * tupleSize."]
    #[doc = ""]
    pub fn HAPI_SetVolumeTileFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        tile: *const HAPI_VolumeTileInfo,
        values_array: *const f32,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the values of an int tile: this is an 8x8x8 subsection of"]
    #[doc = "         the volume."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      tile"]
    #[doc = "                 The tile that the volume will be input into."]
    #[doc = ""]
    #[doc = " @param[in]      values_array"]
    #[doc = "                 The values of the individual voxel tiles in the"]
    #[doc = "                 volume. The length of this array should"]
    #[doc = "                 be ( 8 ^ 3 ) * tupleSize."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length should be ( 8 ^ 3 ) * tupleSize."]
    #[doc = ""]
    pub fn HAPI_SetVolumeTileIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        tile: *const HAPI_VolumeTileInfo,
        values_array: *const ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the values of a float voxel in the volume."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      x_index"]
    #[doc = "                 The x index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      y_index"]
    #[doc = "                 The y index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      z_index"]
    #[doc = "                 The z index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]     values_array"]
    #[doc = "                 The values of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      value_count"]
    #[doc = "                 Should be equal to the volume's"]
    #[doc = "                 ::HAPI_VolumeInfo::tupleSize."]
    #[doc = "                 <!-- source ::HAPI_VolumeInfo::tupleSize -->"]
    #[doc = ""]
    pub fn HAPI_SetVolumeVoxelFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        x_index: ::std::os::raw::c_int,
        y_index: ::std::os::raw::c_int,
        z_index: ::std::os::raw::c_int,
        values_array: *const f32,
        value_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the values of a integer voxel in the volume."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]      x_index"]
    #[doc = "                 The x index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      y_index"]
    #[doc = "                 The y index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      z_index"]
    #[doc = "                 The z index/coordinate of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]     values_array"]
    #[doc = "                 The values of the voxel."]
    #[doc = ""]
    #[doc = " @param[in]      value_count"]
    #[doc = "                 Should be equal to the volume's"]
    #[doc = "                 ::HAPI_VolumeInfo::tupleSize."]
    #[doc = "                 <!-- source ::HAPI_VolumeInfo::tupleSize -->"]
    #[doc = ""]
    pub fn HAPI_SetVolumeVoxelIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        x_index: ::std::os::raw::c_int,
        y_index: ::std::os::raw::c_int,
        z_index: ::std::os::raw::c_int,
        values_array: *const ::std::os::raw::c_int,
        value_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the bounding values of a volume."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     x_min"]
    #[doc = "                 The minimum x value of the volume's bounding box."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     y_min"]
    #[doc = "                 The minimum y value of the volume's bounding box."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     z_min"]
    #[doc = "                 The minimum z value of the volume's bounding box."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     x_max"]
    #[doc = "                 The maximum x value of the volume's bounding box."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     y_max"]
    #[doc = "                 The maximum y value of the volume's bounding box."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     z_max"]
    #[doc = "                 The maximum z value of the volume's bounding box."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     x_center"]
    #[doc = "                 The x value of the volume's bounding box center."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     y_center"]
    #[doc = "                 The y value of the volume's bounding box center."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    #[doc = " @param[out]     z_center"]
    #[doc = "                 The z value of the volume's bounding box center."]
    #[doc = "                 Can be null if you do not want this value."]
    #[doc = ""]
    pub fn HAPI_GetVolumeBounds(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        x_min: *mut f32,
        y_min: *mut f32,
        z_min: *mut f32,
        x_max: *mut f32,
        y_max: *mut f32,
        z_max: *mut f32,
        x_center: *mut f32,
        y_center: *mut f32,
        z_center: *mut f32,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the height field data for a terrain volume with the values from"]
    #[doc = "         a flattened 2D array of float."]
    #[doc = "         ::HAPI_SetVolumeInfo() should be called first to make sure that the"]
    #[doc = "         volume and its info are initialized."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[in]     values_array"]
    #[doc = "                 Heightfield flattened array. Should be at least the size of"]
    #[doc = "                 @p start + @p length."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The start at least 0 and at most"]
    #[doc = "                 ( ::HAPI_VolumeInfo::xLength * ::HAPI_VolumeInfo::yLength )"]
    #[doc = "                 - @p length."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length should be at least 1 or at most"]
    #[doc = "                 ( ::HAPI_VolumeInfo::xLength * ::HAPI_VolumeInfo::yLength )"]
    #[doc = "                 - @p start."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 The name of the volume used for the heightfield."]
    #[doc = "                 If set to \"height\" the values will be used for height information,"]
    #[doc = "                 if not, the data will used as a mask."]
    #[doc = ""]
    pub fn HAPI_SetHeightFieldData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        name: *const ::std::os::raw::c_char,
        values_array: *const f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve the visualization meta-data of the volume."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     visual_info"]
    #[doc = "                 The meta-data associated with the visualization"]
    #[doc = "                 settings of the part specified by the previous"]
    #[doc = "                 parameters."]
    #[doc = ""]
    pub fn HAPI_GetVolumeVisualInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        visual_info: *mut HAPI_VolumeVisualInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve any meta-data about the curves, including the"]
    #[doc = "         curve's type, order, and periodicity."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     info"]
    #[doc = "                 The curve info represents the meta-data about"]
    #[doc = "                 the curves, including the type, order,"]
    #[doc = "                 and periodicity."]
    #[doc = ""]
    pub fn HAPI_GetCurveInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        info: *mut HAPI_CurveInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve the number of vertices for each curve in the part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     counts_array"]
    #[doc = "                 The number of cvs each curve contains"]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The index of the first curve."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of curves' counts to retrieve."]
    #[doc = ""]
    pub fn HAPI_GetCurveCounts(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        counts_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve the orders for each curve in the part if the"]
    #[doc = "         curve has varying order."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     orders_array"]
    #[doc = "                 The order of each curve will be returned in this"]
    #[doc = "                 array."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The index of the first curve."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of curves' orders to retrieve."]
    #[doc = ""]
    pub fn HAPI_GetCurveOrders(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        orders_array: *mut ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Retrieve the knots of the curves in this part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id."]
    #[doc = ""]
    #[doc = " @param[out]     knots_array"]
    #[doc = "                 The knots of each curve will be returned in this"]
    #[doc = "                 array."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The index of the first curve."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of curves' knots to retrieve. The"]
    #[doc = "                 length of all the knots on a single curve is"]
    #[doc = "                 the order of that curve plus the number of"]
    #[doc = "                 vertices (see ::HAPI_GetCurveOrders(),"]
    #[doc = "                 and ::HAPI_GetCurveCounts())."]
    #[doc = ""]
    pub fn HAPI_GetCurveKnots(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        knots_array: *mut f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set meta-data for the curve mesh, including the"]
    #[doc = "         curve type, order, and periodicity."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently unused. Input asset geos are assumed"]
    #[doc = "                 to have only one part."]
    #[doc = ""]
    #[doc = " @param[in]      info"]
    #[doc = "                 The curve info represents the meta-data about"]
    #[doc = "                 the curves, including the type, order,"]
    #[doc = "                 and periodicity."]
    #[doc = ""]
    pub fn HAPI_SetCurveInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        info: *const HAPI_CurveInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the number of vertices for each curve in the part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently unused. Input asset geos are assumed"]
    #[doc = "                 to have only one part."]
    #[doc = ""]
    #[doc = " @param[in]      counts_array"]
    #[doc = "                 The number of cvs each curve contains."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The index of the first curve."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of curves' counts to set."]
    #[doc = "                 <!-- source arglength(counts_array) -->"]
    #[doc = ""]
    pub fn HAPI_SetCurveCounts(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        counts_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the orders for each curve in the part if the"]
    #[doc = "         curve has varying order."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently unused. Input asset geos are assumed"]
    #[doc = "                 to have only one part."]
    #[doc = ""]
    #[doc = " @param[in]      orders_array"]
    #[doc = "                 The orders of each curve."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The index of the first curve."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of curves' orders to retrieve."]
    #[doc = "                 <!-- source arglength(orders_array) -->"]
    #[doc = ""]
    pub fn HAPI_SetCurveOrders(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        orders_array: *const ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the knots of the curves in this part."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 Currently unused. Input asset geos are assumed"]
    #[doc = "                 to have only one part."]
    #[doc = ""]
    #[doc = " @param[in]      knots_array"]
    #[doc = "                 The knots of each curve."]
    #[doc = ""]
    #[doc = " @param[in]      start"]
    #[doc = "                 The index of the first curve."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The number of curves' knots to set. The"]
    #[doc = "                 length of all the knots on a single curve is"]
    #[doc = "                 the order of that curve plus the number of"]
    #[doc = "                 vertices (see ::HAPI_SetCurveOrders(),"]
    #[doc = "                 and ::HAPI_SetCurveCounts())."]
    #[doc = ""]
    pub fn HAPI_SetCurveKnots(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        knots_array: *const f32,
        start: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the box info on a geo part (if the part is a box)."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      geo_node_id"]
    #[doc = "                 The geo node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id of the"]
    #[doc = ""]
    #[doc = " @param[out]     box_info"]
    #[doc = "                 The returned box info."]
    #[doc = ""]
    pub fn HAPI_GetBoxInfo(
        session: *const HAPI_Session,
        geo_node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        box_info: *mut HAPI_BoxInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the sphere info on a geo part (if the part is a sphere)."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      geo_node_id"]
    #[doc = "                 The geo node id."]
    #[doc = ""]
    #[doc = " @param[in]      part_id"]
    #[doc = "                 The part id of the"]
    #[doc = ""]
    #[doc = " @param[out]     sphere_info"]
    #[doc = "                 The returned sphere info."]
    #[doc = ""]
    pub fn HAPI_GetSphereInfo(
        session: *const HAPI_Session,
        geo_node_id: HAPI_NodeId,
        part_id: HAPI_PartId,
        sphere_info: *mut HAPI_SphereInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the number of currently active caches."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     active_cache_count"]
    #[doc = "                 The number of currently active caches."]
    #[doc = ""]
    pub fn HAPI_GetActiveCacheCount(
        session: *const HAPI_Session,
        active_cache_count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the names of the currently active caches."]
    #[doc = ""]
    #[doc = "         Requires a valid active cache count which you get from:"]
    #[doc = "         ::HAPI_GetActiveCacheCount()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     cache_names_array"]
    #[doc = "                 String array with the returned cache names. Must be"]
    #[doc = "                 at least the size of @a active_cache_count."]
    #[doc = ""]
    #[doc = " @param[in]      active_cache_count"]
    #[doc = "                 The count returned by ::HAPI_GetActiveCacheCount()."]
    #[doc = "                 <!-- source ::HAPI_GetActiveCacheCount -->"]
    #[doc = ""]
    pub fn HAPI_GetActiveCacheNames(
        session: *const HAPI_Session,
        cache_names_array: *mut HAPI_StringHandle,
        active_cache_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Lets you inspect specific properties of the different memory"]
    #[doc = "         caches in the current Houdini context."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      cache_name"]
    #[doc = "                 Cache name from ::HAPI_GetActiveCacheNames()."]
    #[doc = ""]
    #[doc = " @param[in]      cache_property"]
    #[doc = "                 The specific property of the cache to get the value for."]
    #[doc = ""]
    #[doc = " @param[out]     property_value"]
    #[doc = "                 Returned property value."]
    #[doc = ""]
    pub fn HAPI_GetCacheProperty(
        session: *const HAPI_Session,
        cache_name: *const ::std::os::raw::c_char,
        cache_property: HAPI_CacheProperty,
        property_value: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Lets you modify specific properties of the different memory"]
    #[doc = "         caches in the current Houdini context. This includes clearing"]
    #[doc = "         caches, reducing their memory use, or changing how memory limits"]
    #[doc = "         are respected by a cache."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      cache_name"]
    #[doc = "                 Cache name from ::HAPI_GetActiveCacheNames()."]
    #[doc = ""]
    #[doc = " @param[in]      cache_property"]
    #[doc = "                 The specific property of the cache to modify."]
    #[doc = ""]
    #[doc = " @param[in]      property_value"]
    #[doc = "                 The new property value."]
    #[doc = ""]
    pub fn HAPI_SetCacheProperty(
        session: *const HAPI_Session,
        cache_name: *const ::std::os::raw::c_char,
        cache_property: HAPI_CacheProperty,
        property_value: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Saves a geometry to file.  The type of file to save is"]
    #[doc = "         to be determined by the extension ie. .bgeo, .obj"]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      file_name"]
    #[doc = "                 The name of the file to be saved.  The extension"]
    #[doc = "                 of the file determines its type."]
    #[doc = ""]
    pub fn HAPI_SaveGeoToFile(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        file_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads a geometry file and put its contents onto a SOP"]
    #[doc = "         node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      file_name"]
    #[doc = "                 The name of the file to be loaded"]
    #[doc = ""]
    pub fn HAPI_LoadGeoFromFile(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        file_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Saves the node and all its contents to file."]
    #[doc = "         The saved file can be loaded by calling ::HAPI_LoadNodeFromFile."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      file_name"]
    #[doc = "                 The name of the file to be saved.  The extension"]
    #[doc = "                 of the file determines its type."]
    #[doc = ""]
    pub fn HAPI_SaveNodeToFile(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        file_name: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads and creates a previously saved node and all"]
    #[doc = "         its contents from given file."]
    #[doc = "         The saved file must have been created by calling"]
    #[doc = "         ::HAPI_SaveNodeToFile."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      file_name"]
    #[doc = "                 The name of the file to be loaded"]
    #[doc = ""]
    #[doc = " @param[in]      parent_node_id"]
    #[doc = "                 The parent node id of the Geometry object."]
    #[doc = ""]
    #[doc = " @param[in]      node_label"]
    #[doc = "                 The name of the new Geometry object."]
    #[doc = ""]
    #[doc = " @param[in]      cook_on_load"]
    #[doc = "                 Set to true if you wish the nodes to cook as soon"]
    #[doc = "                 as they are created. Otherwise, you will have to"]
    #[doc = "                 call ::HAPI_CookNode() explicitly for each after you"]
    #[doc = "                 call this function."]
    #[doc = ""]
    #[doc = " @param[out]     new_node_id"]
    #[doc = "                 The newly created node id."]
    #[doc = ""]
    pub fn HAPI_LoadNodeFromFile(
        session: *const HAPI_Session,
        file_name: *const ::std::os::raw::c_char,
        parent_node_id: HAPI_NodeId,
        node_label: *const ::std::os::raw::c_char,
        cook_on_load: HAPI_Bool,
        new_node_id: *mut HAPI_NodeId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Cache the current state of the geo to memory, given the"]
    #[doc = "         format, and return the size. Use this size with your call"]
    #[doc = "         to ::HAPI_SaveGeoToMemory() to copy the cached geo to your"]
    #[doc = "         buffer. It is guaranteed that the size will not change between"]
    #[doc = "         your call to ::HAPI_GetGeoSize() and ::HAPI_SaveGeoToMemory()."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      format"]
    #[doc = "                 The file format, ie. \".obj\", \".bgeo.sc\" etc."]
    #[doc = ""]
    #[doc = " @param[out]     size"]
    #[doc = "                 The size of the buffer required to hold the output."]
    #[doc = ""]
    pub fn HAPI_GetGeoSize(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        format: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Saves the cached geometry to your buffer in memory,"]
    #[doc = "         whose format and required size is identified by the call to"]
    #[doc = "         ::HAPI_GetGeoSize(). The call to ::HAPI_GetGeoSize() is"]
    #[doc = "         required as ::HAPI_GetGeoSize() does the actual saving work."]
    #[doc = ""]
    #[doc = "         Also note that this call to ::HAPI_SaveGeoToMemory will delete"]
    #[doc = "         the internal geo buffer that was cached in the previous call"]
    #[doc = "         to ::HAPI_GetGeoSize(). This means that you will need to call"]
    #[doc = "         ::HAPI_GetGeoSize() again before you can call this function."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     buffer"]
    #[doc = "                 The buffer we will write into."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The size of the buffer passed in."]
    #[doc = "                 <!-- source ::HAPI_GetGeoSize -->"]
    #[doc = ""]
    pub fn HAPI_SaveGeoToMemory(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Loads a geometry from memory and put its"]
    #[doc = "         contents onto a SOP node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      format"]
    #[doc = "                 The file format, ie. \"obj\", \"bgeo\" etc."]
    #[doc = ""]
    #[doc = " @param[in]      buffer"]
    #[doc = "                 The buffer we will read the geometry from."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The size of the buffer passed in."]
    #[doc = "                 <!-- source arglength(buffer) -->"]
    #[doc = ""]
    pub fn HAPI_LoadGeoFromMemory(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        format: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the specified node's display flag."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      onOff"]
    #[doc = "                 Display flag."]
    #[doc = ""]
    pub fn HAPI_SetNodeDisplay(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        onOff: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the specified node's total cook count, including"]
    #[doc = "\t    its children, if specified."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      node_type_filter"]
    #[doc = "                 The node type by which to filter the children."]
    #[doc = ""]
    #[doc = " @param[in]      node_flags_filter"]
    #[doc = "                 The node flags by which to filter the children."]
    #[doc = ""]
    #[doc = " @param[in]      recursive"]
    #[doc = "                 Whether or not to include the specified node's"]
    #[doc = "                 children cook count in the tally."]
    #[doc = ""]
    #[doc = " @param[out]     count"]
    #[doc = "                 The number of cooks in total for this session."]
    #[doc = ""]
    pub fn HAPI_GetTotalCookCount(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        node_type_filter: HAPI_NodeTypeBits,
        node_flags_filter: HAPI_NodeFlagsBits,
        recursive: HAPI_Bool,
        count: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Enable or disable SessionSync mode."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      enable"]
    #[doc = "                 Enable or disable SessionSync mode."]
    #[doc = ""]
    pub fn HAPI_SetSessionSync(session: *const HAPI_Session, enable: HAPI_Bool) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the ::HAPI_Viewport info for synchronizing viewport in"]
    #[doc = "\t    SessionSync. When SessionSync is running this will"]
    #[doc = "\t    return Houdini's current viewport information."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[out]     viewport"]
    #[doc = "                 The output ::HAPI_Viewport."]
    #[doc = ""]
    pub fn HAPI_GetViewport(
        session: *const HAPI_Session,
        viewport: *mut HAPI_Viewport,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the ::HAPI_Viewport info for synchronizing viewport in"]
    #[doc = "\t    SessionSync. When SessionSync is running, this can be"]
    #[doc = "\t    used to set the viewport information which Houdini"]
    #[doc = "\t    will then synchronizse with for its viewport."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[in]      viewport"]
    #[doc = "                 A ::HAPI_Viewport that stores the viewport."]
    #[doc = ""]
    pub fn HAPI_SetViewport(
        session: *const HAPI_Session,
        viewport: *const HAPI_Viewport,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Get the ::HAPI_SessionSyncInfo for synchronizing SessionSync"]
    #[doc = "\t    state between Houdini and Houdini Engine integrations."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[out]     session_sync_info"]
    #[doc = "                 The output ::HAPI_SessionSyncInfo."]
    #[doc = ""]
    pub fn HAPI_GetSessionSyncInfo(
        session: *const HAPI_Session,
        session_sync_info: *mut HAPI_SessionSyncInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Set the ::HAPI_SessionSyncInfo for synchronizing SessionSync"]
    #[doc = "\t    state between Houdini and Houdini Engine integrations."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[in]      session_sync_info"]
    #[doc = "                 A ::HAPI_SessionSyncInfo that stores the state."]
    #[doc = ""]
    pub fn HAPI_SetSessionSyncInfo(
        session: *const HAPI_Session,
        session_sync_info: *const HAPI_SessionSyncInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief Return an array of PDG graph context names and ids, the first"]
    #[doc = "        count names will be returned.  These ids can be used"]
    #[doc = "        with ::HAPI_GetPDGEvents and ::HAPI_GetPDGState.  The values"]
    #[doc = "        of the names can be retrieved with ::HAPI_GetString."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[out]     num_contexts"]
    #[doc = "                 Total number of PDG graph contexts found."]
    #[doc = ""]
    #[doc = " @param[out]     context_names_array"]
    #[doc = "                 Array of int (string handles) to house the"]
    #[doc = "                 context names.  These handles are valid until the next"]
    #[doc = "                 call to this function."]
    #[doc = ""]
    #[doc = " @param[out]     context_id_array"]
    #[doc = "                 Array of graph context ids."]
    #[doc = ""]
    #[doc = " @param[in]      count"]
    #[doc = "                 Length of @p context_names_array and @p context_id_array"]
    #[doc = ""]
    pub fn HAPI_GetPDGGraphContexts(
        session: *const HAPI_Session,
        num_contexts: *mut ::std::os::raw::c_int,
        context_names_array: *mut HAPI_StringHandle,
        context_id_array: *mut HAPI_PDG_GraphContextId,
        count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      top_node_id"]
    #[doc = "                 The id of the TOP node to query its graph context."]
    #[doc = ""]
    #[doc = " @param[out]     context_id"]
    #[doc = "                 The PDG graph context id."]
    #[doc = ""]
    pub fn HAPI_GetPDGGraphContextId(
        session: *const HAPI_Session,
        top_node_id: HAPI_NodeId,
        context_id: *mut HAPI_PDG_GraphContextId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = "        Progress can be checked with ::HAPI_GetPDGState() and"]
    #[doc = "        ::HAPI_GetPDGState(). Events generated during this cook can be"]
    #[doc = "        collected with ::HAPI_GetPDGEvents(). Any uncollected events will be"]
    #[doc = "         discarded at the start of the cook."]
    #[doc = ""]
    #[doc = "        If there are any $HIPFILE file dependencies on nodes involved in the cook"]
    #[doc = "        a hip file will be automatically saved to $HOUDINI_TEMP_DIR directory so"]
    #[doc = "        that it can be copied to the working directory by the scheduler.  This means"]
    #[doc = "        $HIP will be equal to $HOUDINI_TEMP_DIR."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = ""]
    #[doc = " @param[in]      cook_node_id"]
    #[doc = "                 The node id of a TOP node for the cook operation."]
    #[doc = ""]
    #[doc = " @param[in]      generate_only"]
    #[doc = "                 1 means only static graph generation will done.  0 means"]
    #[doc = "                 a full graph cook.  Generation is always blocking."]
    #[doc = ""]
    #[doc = " @param[in]      blocking"]
    #[doc = "                 0 means return immediately and cooking will be done"]
    #[doc = "                 asynchronously.   1 means return when cooking completes."]
    #[doc = ""]
    pub fn HAPI_CookPDG(
        session: *const HAPI_Session,
        cook_node_id: HAPI_NodeId,
        generate_only: ::std::os::raw::c_int,
        blocking: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = "        will remove those events from the queue.  Events collection is restarted"]
    #[doc = "        by calls to ::HAPI_CookPDG()."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      graph_context_id"]
    #[doc = "                 The id of the graph context"]
    #[doc = ""]
    #[doc = " @param[out]     event_array"]
    #[doc = "                 buffer of ::HAPI_PDG_EventInfo of size at least length."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The size of the buffer passed in."]
    #[doc = ""]
    #[doc = " @param[out]     event_count"]
    #[doc = "                 Number of events removed from queue and copied to buffer."]
    #[doc = ""]
    #[doc = " @param[out]     remaining_events"]
    #[doc = "                 Number of queued events remaining after this operation."]
    #[doc = ""]
    pub fn HAPI_GetPDGEvents(
        session: *const HAPI_Session,
        graph_context_id: HAPI_PDG_GraphContextId,
        event_array: *mut HAPI_PDG_EventInfo,
        length: ::std::os::raw::c_int,
        event_count: *mut ::std::os::raw::c_int,
        remaining_events: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      graph_context_id"]
    #[doc = "                 The graph context id"]
    #[doc = ""]
    #[doc = " @param[out]     pdg_state"]
    #[doc = "                 One of ::HAPI_PDG_State."]
    #[doc = ""]
    pub fn HAPI_GetPDGState(
        session: *const HAPI_Session,
        graph_context_id: HAPI_PDG_GraphContextId,
        pdg_state: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = "        will not be submitted to the graph until it is committed with"]
    #[doc = "        ::HAPI_CommitWorkitems().  The node is expected to be a generator type."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     workitem_id"]
    #[doc = "                 The id of the pending workitem."]
    #[doc = ""]
    #[doc = " @param[in]      name"]
    #[doc = "                 The null-terminated name of the workitem.  The name will"]
    #[doc = "                 be automatically suffixed to make it unique."]
    #[doc = ""]
    #[doc = " @param[in]      index"]
    #[doc = "                 The index of the workitem.  The semantics of the index"]
    #[doc = "                 are user defined."]
    #[doc = ""]
    pub fn HAPI_CreateWorkitem(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: *mut HAPI_PDG_WorkitemId,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      graph_context_id"]
    #[doc = "                 The graph context that the workitem is in."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the workitem."]
    #[doc = ""]
    #[doc = " @param[out]     workitem_info"]
    #[doc = "                 The returned ::HAPI_PDG_WorkitemInfo for the workitem.  Note"]
    #[doc = "                 that the enclosed string handle is only valid until the next"]
    #[doc = "                 call to this function."]
    #[doc = ""]
    pub fn HAPI_GetWorkitemInfo(
        session: *const HAPI_Session,
        graph_context_id: HAPI_PDG_GraphContextId,
        workitem_id: HAPI_PDG_WorkitemId,
        workitem_info: *mut HAPI_PDG_WorkitemInfo,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the pending workitem returned by ::HAPI_CreateWorkitem()"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the data member"]
    #[doc = ""]
    #[doc = " @param[in]      values_array"]
    #[doc = "                 array of integer values"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 number of values to copy from values_array to the parameter"]
    #[doc = ""]
    pub fn HAPI_SetWorkitemIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        values_array: *const ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the pending workitem returned by ::HAPI_CreateWorkitem()"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the workitem data member"]
    #[doc = ""]
    #[doc = " @param[in]      values_array"]
    #[doc = "                 array of float values"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 number of values to copy from values_array to the parameter"]
    #[doc = ""]
    pub fn HAPI_SetWorkitemFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        values_array: *const f32,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the created workitem returned by HAPI_CreateWorkitem()"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the data member"]
    #[doc = ""]
    #[doc = " @param[in]      data_index"]
    #[doc = "                 index of the string data member"]
    #[doc = ""]
    #[doc = " @param[in]      value"]
    #[doc = "                 null-terminated string to copy to the workitem data member"]
    #[doc = ""]
    pub fn HAPI_SetWorkitemStringData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        data_index: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_char,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id for which the pending workitems have been"]
    #[doc = "                 created but not yet injected."]
    #[doc = ""]
    pub fn HAPI_CommitWorkitems(session: *const HAPI_Session, node_id: HAPI_NodeId) -> HAPI_Result;
}
extern "C" {
    #[doc = "        Should be used with ::HAPI_GetWorkitems."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     num"]
    #[doc = "                 The number of workitems."]
    #[doc = ""]
    pub fn HAPI_GetNumWorkitems(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        num: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[out]     workitem_ids_array"]
    #[doc = "                 buffer for resulting array of ::HAPI_PDG_WorkitemId"]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length of the @p workitem_ids buffer"]
    #[doc = ""]
    pub fn HAPI_GetWorkitems(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_ids_array: *mut ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = "        It is the length of the array of data."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the workitem"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the data member"]
    #[doc = ""]
    #[doc = " @param[out]     length"]
    #[doc = "                 The length of the data member array"]
    #[doc = ""]
    pub fn HAPI_GetWorkitemDataLength(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the workitem"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the data member"]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 buffer of at least size length to copy the data into.  The required"]
    #[doc = "                 length should be determined by ::HAPI_GetWorkitemDataLength()."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length of @p data_array"]
    #[doc = ""]
    pub fn HAPI_GetWorkitemIntData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        data_array: *mut ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the workitem"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the data member"]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 buffer of at least size length to copy the data into.  The required"]
    #[doc = "                 length should be determined by ::HAPI_GetWorkitemDataLength()."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length of the @p data_array"]
    #[doc = ""]
    pub fn HAPI_GetWorkitemFloatData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        data_array: *mut f32,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the workitem"]
    #[doc = ""]
    #[doc = " @param[in]      data_name"]
    #[doc = "                 null-terminated name of the data member"]
    #[doc = ""]
    #[doc = " @param[out]     data_array"]
    #[doc = "                 buffer of at least size length to copy the data into.  The required"]
    #[doc = "                 length should be determined by ::HAPI_GetWorkitemDataLength()."]
    #[doc = "                 The data is an array of ::HAPI_StringHandle which can be used with"]
    #[doc = "                 ::HAPI_GetString().  The string handles are valid until the"]
    #[doc = "                 next call to this function."]
    #[doc = ""]
    #[doc = " @param[in]      length"]
    #[doc = "                 The length of @p data_array"]
    #[doc = ""]
    pub fn HAPI_GetWorkitemStringData(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        data_name: *const ::std::os::raw::c_char,
        data_array: *mut HAPI_StringHandle,
        length: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = " @brief  Gets the info for workitem results."]
    #[doc = "        The number of workitem results is found on the ::HAPI_PDG_WorkitemInfo"]
    #[doc = "        returned by HAPI_GetWorkitemInfo."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      workitem_id"]
    #[doc = "                 The id of the workitem"]
    #[doc = ""]
    #[doc = " @param[out]     resultinfo_array"]
    #[doc = "                 Buffer to fill with info structs.  String handles are valid"]
    #[doc = "                 until the next call of this function."]
    #[doc = ""]
    #[doc = " @param[in]      resultinfo_count"]
    #[doc = "                 The length of @p resultinfo_array"]
    #[doc = ""]
    pub fn HAPI_GetWorkitemResultInfo(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        workitem_id: HAPI_PDG_WorkitemId,
        resultinfo_array: *mut HAPI_PDG_WorkitemResultInfo,
        resultinfo_count: ::std::os::raw::c_int,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = "         deletes all workitems on the node."]
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      node_id"]
    #[doc = "                 The node id."]
    #[doc = ""]
    #[doc = " @param[in]      clean_results"]
    #[doc = "                 Remove the results generated by the node."]
    #[doc = "                 <!-- default 0 -->"]
    #[doc = ""]
    pub fn HAPI_DirtyPDGNode(
        session: *const HAPI_Session,
        node_id: HAPI_NodeId,
        clean_results: HAPI_Bool,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      graph_context_id"]
    #[doc = "                 The id of the graph context"]
    #[doc = ""]
    pub fn HAPI_PausePDGCook(
        session: *const HAPI_Session,
        graph_context_id: HAPI_PDG_GraphContextId,
    ) -> HAPI_Result;
}
extern "C" {
    #[doc = ""]
    #[doc = " @param[in]      session"]
    #[doc = "                 The session of Houdini you are interacting with."]
    #[doc = "                 See @ref HAPI_Sessions for more on sessions."]
    #[doc = "                 Pass NULL to just use the default in-process session."]
    #[doc = "                 <!-- default NULL -->"]
    #[doc = ""]
    #[doc = " @param[in]      graph_context_id"]
    #[doc = "                 The id of the graph context"]
    #[doc = ""]
    pub fn HAPI_CancelPDGCook(
        session: *const HAPI_Session,
        graph_context_id: HAPI_PDG_GraphContextId,
    ) -> HAPI_Result;
}
